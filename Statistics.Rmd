---
title: "Psyllid microbiome Statistics"
author: "Alexander Piper"
date: "14/08/2019"
output: html_document
editor_options: 
  chunk_output_type: console
---

## Load packages 

```{r install & Load packages} 
#Set required packages
.cran_packages <- c("ggplot2", "gridExtra", "tidyverse", "scales", "stringdist", "patchwork", "vegan", "ggpubr", "seqinr", "viridis", "ape", "sp", "data.table", "RColorBrewer", "ggtree")
.bioc_packages <- c("dada2", "phyloseq", "DECIPHER","Biostrings","ShortRead","psadd","microbiome","philr")

sapply(c(.cran_packages,.bioc_packages), require, character.only = TRUE)

#Load helper functions 
source('R/helper_functions.R')

options(stringsAsFactors = FALSE)

```



### Read in phyloseq and Summarise taxonomic assignment

```{r sum taxa}
ps <- readRDS("output/rds/ps_rdp.rds")

#Fraction of reads assigned to each taxonomic rank
sum_reads <- speedyseq::psmelt(ps) %>%
  gather("Rank","Name",rank_names(ps)) %>%
  group_by(Rank) %>% 
  mutate(Name = replace(Name, str_detect(Name, "__"),NA)) %>% # This line turns the "__" we added to lower ranks back to NA's
  summarize(Reads_classified = sum(Abundance * !is.na(Name))) %>%
  mutate(Frac_reads = Reads_classified / sum(sample_sums(ps))) %>%
  mutate(Rank = factor(Rank, rank_names(ps))) %>%
  arrange(Rank)

#Fraction of ASV's assigned to each taxonomic rank
sum_otu <- tax_table(ps) %>%
  as("matrix") %>%
  as_tibble(rownames="OTU") %>%
  gather("Rank","Name",rank_names(ps)) %>%
  group_by(Rank) %>%
  mutate(Name = replace(Name, str_detect(Name, "__"),NA)) %>% # This line turns the "__" we added to lower ranks back to NA's
  summarize(OTUs_classified = sum(!is.na(Name))) %>%
  mutate(Frac_OTUs = OTUs_classified / ntaxa(ps)) %>%
  mutate(Rank = factor(Rank, rank_names(ps))) %>%
  arrange(Rank)

print(sum_reads)
print(sum_otu)
```


## Detect and remove outlier Samples

Detecting and potentially removing samples outliers (those samples with underlying data that do not conform to experimental or biological expectations) can be useful for minimizing technical variance. This can be caused by a number of reasons, including low-reads assigned to that sample. In this case we remove all samples below 1000 reads, as these include all samples contributing to lower than usual ASV counts.

```{r sample-removal-identification}
## Remove mocks
rm_mocks <- c("mockA_S51", "MockEven_S193", "Mock_S192", "PCRctrl_S191", "MockStaggered_S194", "PCRctrl_S191", "91_S167")
nsamples(ps)
ps0 <- ps %>% subset_samples(!sample_names(ps) %in% rm_mocks) %>% #Remove mocks
       
        filter_taxa(function(x) mean(x) > 0, TRUE) #Drop missing taxa from table 
nsamples(ps0)

# Format a data table to combine sample summary data with sample variable data
ss.df <- merge(as.data.frame(sample_data(ps0)), data.frame("ASV" = sample_sums(ps0)), by ="row.names")

# Plot Count of ASVs and read s
threshold = 1000

gg.asv.boxplot <- merge(as.data.frame(sample_data(ps0)), data.frame("Reads" = sample_sums(ps0)), by ="row.names") %>%
  ggplot( aes(x= Sample.Name, y = Reads, color = Sample.Name, shape=replicated)) + 
  geom_boxplot(outlier.colour="RED", position = position_dodge(width = 0.8)) +
  geom_jitter(size = 2, alpha = 0.6) +
  scale_y_log10() +
  geom_hline(yintercept = threshold, lty = 2) +
  theme(legend.position = "none",
        axis.text.x = element_text(angle=90, vjust=1))

print(gg.asv.boxplot)
## Plot richness

gg.rich <- plot_richness(ps0, measures="Observed")
print(gg.rich)

#Remove all samples under the minimum read threshold 
ps1 <- prune_samples(sample_sums(ps0)>=threshold, ps0) # 
ps1 <- filter_taxa(ps1, function(x) mean(x) > 0, TRUE) #Drop missing taxa from table
print(paste(nsamples(ps) - nsamples(ps1), " Samples and ", ntaxa(ps) - ntaxa(ps1), " taxa Dropped"))
```


## Process Replicates

### Compare reproducibilty of replicates

Rarefaction curves are useful	to	assess	sensitivity	of	sample	size	to	observed	alpha-diversity estimates.
```{r replicate reproducibility}
#Subset to replicated samples
ps.reps <- subset_samples(ps1, replicated == TRUE)

#Plot read differences between replicates
gg.reps <- plot_bar(ps.reps, x="Sample", y="Abundance", fill="Phylum") +
  facet_grid(~Sample.Name, drop=TRUE, scales="free_x") +
  geom_hline(yintercept=1000)

#Plot rarefaction curve
rarecurve(otu_table(ps.reps), step=50, cex=0.5)

#Rarefy replicates to same read depth
nspec <- specnumber(otu_table(ps.reps)) # observed number of species
raremax <- min(rowSums(otu_table(ps.reps)))
rare <- rrarefy(otu_table(ps.reps),raremax)

#PCA of rarefied samples
raredist <- vegan::vegdist(rare, method="euclidean")

r.pcx <- prcomp(raredist)

pc_samp <- data.frame(SampleID = rownames(r.pcx$x), r.pcx$x[, 1:2])%>%
  left_join(samdf, by="SampleID")
pc_otu <- data.frame(OTU = rownames(r.pcx$rotation), r.pcx$rotation[, 1:2])

# calculate percent variance explained for the axis labels
pc1 <- round(r.pcx$sdev[1]^2/sum(r.pcx$sdev^2),2)
pc2 <- round(r.pcx$sdev[2]^2/sum(r.pcx$sdev^2),2)
pc_xlab <- paste("PC1: ", pc1, sep="")
pc_ylab <- paste("PC2: ", pc2, sep="")

library(ggplot2)
gg.reps <- ggplot(data=pc_samp, aes(x=PC1, y=PC2, colour=SampleID, label=SampleID)) + 
  geom_point(alpha=0.5, size=3) +
  geom_text() +
  #geom_point(data=pc_otu,aes(PC1, PC2)) +
  theme_bw() + 
  geom_hline(yintercept = 0, linetype=2) +  
  geom_vline(xintercept = 0, linetype=2) +
  xlab(pc_xlab) + 
  ylab(pc_ylab) +
  theme(legend.position = "none")+
  coord_fixed(ratio=pc2/pc1) # Scale plot by variance explained

print(gg.reps)


## Bar plots of pairwise similarity between reps, species, species~hostplant

```

### Merge technical replicates

With only 16 samples replicated, and only on the first 2 sequencing runs i dont think there is a way to explicitly take into account replicate variability, therefore all replicates were merged

```{r replicates}
# Merge replicates
ps.merged <- ps1 %>%
    merge_samples(group = "Sample.Name")

#This loses the sample metadata - Need to add it agian
samdf <- read.csv("sample_data/Sample_info.csv", header=TRUE) %>%
  filter(!duplicated(Sample.Name)) %>%
  set_rownames(.$Sample.Name) %>%
  dplyr::select(c("SampleID", "Sample.Name", "seqrun", "psyllid_spp", "psyllid_genus", "psyllid_family", "hostplant_spp","Collection","Collection.Date"))

sample_data(ps.merged) <- samdf
ps.merged <- filter_taxa(ps.merged, function(x) mean(x) > 0, TRUE) #Drop missing taxa from table
```

## Prevalence assesment

Identification of taxa that are poorly represented in an unsupervised manner can identify taxa that will have little to no effect on downstream analysis. Sufficient removal of these "low prevalance" features can enhance many analysis by focusing statistical testing on taxa common throughout the data. However, for our dataset the problem with prevalence filtering for our dataset is that we dont have many replicates of each psyllid species, and therefore there are some high abundance but low prevalence ASV's we dont want to lose.

If we are agglomerating anyway, the prevalence filter doesnt have any impact really


```{r prevalence-assessment}
# Calculate taxon prevalence across the data set
prevdf <- apply(X = otu_table(ps.merged), MARGIN = ifelse(taxa_are_rows(ps.merged), yes = 1, no = 2), FUN = function(x){sum(x > 0)})

# Add taxonomy and total read counts to prevdf - change this to tidyverse code
prevdf <- data.frame(Prevalence = prevdf, TotalAbundance = taxa_sums(ps.merged), tax_table(ps.merged))

#Prevalence plot
gg.prev <- subset(prevdf, Phylum %in% get_taxa_unique(ps0, "Phylum")) %>%
  ggplot(aes(TotalAbundance, Prevalence / nsamples(ps.merged),color=Genus)) +
  geom_point(size = 3, alpha = 0.7) +
  scale_x_log10() +
  xlab("Total Abundance") + ylab("Prevalence [Frac. Samples]") +
  facet_wrap(~Phylum) +
  theme(legend.position="none") +
  ggtitle("Phylum Prevalence in All Samples\nColored by Family")

gg.prev
```

## Taxon Filtering

The following R chunk removes taxa not-typically part of a bacterial microbiome analysis.

We also remove all taxa contained within the blank sample from other samples

```{r taxon-cleaning}
get_taxa_unique(ps.merged, "Root")
get_taxa_unique(ps.merged, "Class")

ps.merged # Check the number of taxa prior to removal
ps2 <- ps.merged %>%
  subset_taxa(
    Root == "Bacteria" & #This is probably the only required one
    Family  != "Mitochondria" &
    Class   != "Chloroplast" &
    Order   != "Chloroplast" &
    Phylum != "Cyanobacteria"
  )
ps2 # Confirm that the taxa were removed
get_taxa_unique(ps2, "Phylum")
get_taxa_unique(ps2, "Class")
get_taxa_unique(ps2, "Family")

```

# Community Diversity

Instead of using traditional plug-in diversity estiamtors, which only tell us about the diversity of our samples (observed richness), instead of the actual environment (actual richness), we will use the breakaway package which uses biological replicates to estimate the total diversity in the environment. Breakaway estimates the number of missing species based on the sequence depth and  number of rare taxa in the data, and accounts for experimental noise such as the correlation between observed richness and the sequencing depth.

Following the initial estimate of diversity and variance using the breakaway package, we use the betta model of Willis, A. and Bunge, J. (2015) which works like regression but takes into account uncertainty in diversirty estimates betta accounts for strains that are present in the environment but not observed in the samples due to incomplete sampling.. Some of the samples in the initial estimates had large standard errors, indicating that we cannot precisely estimate the total species richness in those sample. In the betta model these samples will be given less weight in the regression than samples with small standard errors on their richness estimates. This is the behaviour we want, because while that sample contains some information, the standard error is telling us that the richness estimate may not be as reliable as other samples' estimates, and we should downweight the importance of that observation relative to observations would smaller standard errors on their richness estimates.

May be interesting to model richness at different taxonomic ranks? - or different slices of the tree?

Psyllid_spp and hostplant_spp are multi-colinear, therefore they cant be included as either additive effects or interaction effects, as it causes the design-matrix to have less than full rank, which means it isn't invertible, and therefore least-squares-techniques fail

This is a univariate phylogenetic analysis, and could be done with the package phylosignal, or a phylogenetic linear mixed model

The effects of phylogenetic signal, defined as “a tendency for related species to resemble each other more than they resemble species drawn at random from the tree” (74), on univariate traits (e.g., microbial alpha diversity) have been examined in parallel with phylosymbiosis studies. Phylogenetic signal indices like Pagel’s λ (75), and Blomberg’s K (76) are based on a random Brownian model of trait evolution (77), These can be calculated with with the phylosignal package

To find the Aitchison distance a centered log-ratio (clr) transformation was performed on ASV count data with the R
165 package CoDaSeq (30) before computing the Euclidean distance between samples with
the R package vegan (31). The Aitchison distance was then used in Permutational Multivariate Analyses of Variance (PERMANOVA, 999 permutations) with the vegan function adonis to test whether community composition was significantly different

Many analysis in community ecology and hypothesis testing benefit from data transformation. Many microbiome data sets do not fit to a normal distribution, but transforming them towards normality may enable more appropriate data for specific statistical tests. 

philr phylogenetic transform is based on balances (binary partitions) along an evolutionary tree (Silverman et al., 2017) that is a replacement for the familiar UniFrac distance metric. Distances determined by phylogenetic transforms have the advantage that the binary partitions chosen have a simple interpretation and the correlation structure of the data is fully accounted for. However, the disadvantage is that only the relationships between the chosen partitions can be examined.# Figure 1: Community composition analysis


## Figure 1 - Community Diversity

Dendrogram and bar plots

Merge species, arrange microbiome by phylogeny, try the mantel tests on the merged data as well (but the seperate is probs more statistically better)

```{r merge spp}
# Model richness
library(breakaway)

#Model richness for all samples by psyllid spp

ba <- breakaway(ps2)

## Check the specification of the model
betta_pic(summary(ba)$estimate, summary(ba)$error)

ba_estimates <- summary(ba) %>%
      add_column("Sample.Name" = ps2 %>% otu_table %>% sample_names) %>%
      left_join(samdf, by = "Sample.Name")

## Model with psyllid_spp as a fixed effect and seqrun as a random effect
bt_sppfixed_hostrandom <- betta_random(chats = ba_estimates$estimate,
                                  ses = ba_estimates$error,
                                  X = model.matrix(~psyllid_spp, data = ba_estimates), # Set fixed effects
                                  groups=ba_estimates$seqrun) # Set random effects


bt_randomdf <- as_tibble(bt_sppfixed_hostrandom$table, rownames="psyllid_spp")%>% 
                mutate(psyllid_spp = str_replace(psyllid_spp, pattern="psyllid_spp", replacement="")) %>%
                magrittr::set_colnames(c("psyllid_spp", "Estimates", "SE", "P")) %>%
                mutate(Estimates = case_when(
                  psyllid_spp == "(Intercept)" ~ Estimates,
                  !psyllid_spp == "(Intercept)" ~ Estimates + 
                                      filter(., str_detect(psyllid_spp, "Intercept") ) %>% # Rescale by intercept
                                      pull(Estimates)
                  
                )) %>%
                mutate(psyllid_spp = str_replace_all(psyllid_spp, pattern="\\(Intercept\\)", replacement =
                                                   unique(ba_estimates$psyllid_spp[which(!ba_estimates$psyllid_spp %in% .$psyllid_spp)])
                                                 )) %>%
                mutate(significant = case_when(
                  P < 0.05 ~ TRUE,
                  P > 0.05 ~ FALSE
                ))

# Merge species for beta diversity
ps.sppmerged <- ps2 %>%
    merge_samples(group = "psyllid_spp", fun=mean)


#This loses the sample metadata - Need to add it agian
samdf <- read.csv("sample_data/Sample_info.csv", header=TRUE) %>%
  filter(!duplicated(psyllid_spp)) %>%
  set_rownames(.$psyllid_spp) %>%
  dplyr::select(c("SampleID", "Sample.Name", "seqrun", "psyllid_spp", "psyllid_genus", "psyllid_family", "hostplant_spp","Collection","Collection.Date"))

sample_data(ps.sppmerged) <- samdf
ps4 <- filter_taxa(ps.sppmerged, function(x) mean(x) > 0, TRUE) #Drop missing taxa from table

#Rename taxa
taxa_names(ps4) <- paste0("SV", seq(ntaxa(ps4)),"-",tax_table(ps4)[,6])

ps4_bar <- #subset_taxa(ps3, !Family == "Enterobacteriaceae") %>%
            ps4 %>%
  speedyseq::tax_glom(taxrank = "Order") %>%           # agglomerate at Order level
  transform_sample_counts(function(x) {x/sum(x)} ) %>% # Transform to rel. abundance
  speedyseq::psmelt() %>%
  mutate(plotlabel = Phylum) %>%
  mutate(plotlabel = case_when(
    Abundance >= 0.01 & Phylum=="Proteobacteria" ~ paste0(Phylum, " - ", Order), # Change this to whatever taxrank we want
    Abundance >= 0.01 & !Phylum=="Proteobacteria"~ Phylum ,
    Abundance < 0.01 ~ "NA"
    )) %>%
  dplyr::na_if("NA") %>%
  select(Sample, plotlabel, Phylum, Order, Abundance)


## Read in tree

## Plotting - arrange by tree
psyllid_tree <- read.tree(text=readLines("sample_data/psyllid_beast_tree.nwk"))

# Match names with alpha diversity
psyllid_tree$tip.label <- psyllid_tree$tip.label %>%
  str_replace_all(pattern="\\.", replacement=" ") %>%
  str_replace_all(pattern="sp$", replacement="sp. ") %>%
  str_replace_all(pattern="Acizzia hakae", replacement="Acizzia hakeae") %>%
  str_replace_all(pattern="POLLENISLAND", replacement="POLLEN ISLAND") %>%
  str_replace_all(pattern="Ctenarytaina fuchsiae$", replacement="Ctenarytaina fuchsia A") %>%
  str_replace_all(pattern="Ctenarytaina fuchsiaeB", replacement="Ctenarytaina fuchsia B") %>%
  str_replace_all(pattern="Ctenarytaina fuchsiaeC", replacement="Ctenarytaina fuchsia C") %>%
  str_replace_all(pattern="Ctenarytaina clavata", replacement="Ctenarytaina clavata sp. ") %>%
  str_replace_all(pattern="Ctenarytaina clavata sp. $", replacement="Ctenarytaina clavata sp. A") %>%
  str_replace_all(pattern="Ctenarytaina sp$", replacement="Ctenarytaina sp. ") %>%
  str_replace_all(pattern="Ctenarytaina unknown", replacement="Ctenarytaina insularis") %>%  
  str_replace_all(pattern="Psylla apicalis A", replacement="Psylla frodobagginsi") %>%
  str_replace_all(pattern="Psylla apicalis B", replacement="Psylla apicalis") %>%
  str_replace_all(pattern="carmichaeliae", replacement="carmichaeliae ") %>%
  str_replace_all(pattern="Psylla apicalis", replacement="Psylla apicalis ") %>% # Should these be A,B or?
  str_replace_all(pattern="Trioza sp", replacement="Trioza sp. ") %>%
  str_replace_all(pattern="Trioza acutaB", replacement="Trioza Acuta B") %>%
  str_replace_all(pattern="BRENDAMAY", replacement="BRENDA MAY") %>%
  str_replace_all(pattern="PRICES", replacement="PRICE'S VALLEY") %>%
  trimws(which="right")


psyllid_tree$tip.label[!psyllid_tree$tip.label %in% bt_randomdf$psyllid_spp]

pruned.tree <- drop.tip(psyllid_tree, psyllid_tree$tip.label[!psyllid_tree$tip.label %in% bt_randomdf$psyllid_spp] )
psyllid_tree$tip.label[!psyllid_tree$tip.label %in%  pruned.tree$tip.label]


# Plot them together
library(ggtree)
library(treeio)
p <- ggtree(pruned.tree) + geom_tiplab(align=TRUE) + geom_nodelab(geom='label') +
    scale_x_continuous(expand=c(0, 0.1)) + theme_tree2()


Fig1 <- facet_plot(p, panel='Relative Abundance', data = ps4_bar %>% mutate(id = Sample), geom=ggstance::geom_barh,
                 mapping=aes(x = Abundance, fill = plotlabel), stat="identity")  + 
  scale_fill_manual(values=colorRampPalette(brewer.pal(11, "Set1"))(length(unique(ps4_bar$plotlabel))-1), na.value="grey")


Fig1 <- facet_plot(Fig1, panel='Species Richness', data = bt_randomdf %>% mutate(id = psyllid_spp),
                          geom=ggstance::geom_pointrangeh,
                           mapping=aes(x=Estimates, xmin=Estimates-SE, xmax=Estimates+SE),
                           stat="identity", size=0.5, colour="#696969") +
  theme_classic2()   +
  theme(legend.position = "bottom",
  panel.grid.major.x = element_line(colour="grey92", size=0.5, linetype="dashed"),
  strip.background = element_rect(fill = "grey92", 
                colour = "black", size = 1)
  )

## Collection_hist
gg.spp <- as_tibble(sample_data(ps2)) %>%
  dplyr::rename(label = psyllid_spp) %>%
  group_by(label) %>%
  summarise(n_species = n()) %>%
  left_join(p$data %>%
  filter(isTip) %>% select(c(label, y))) %>%
  filter(!is.na(y)) %>%
  ggplot(aes(x=factor(.$label, levels=.$label[order(.$y)]), y=1, fill=n_species)) +
  geom_tile() +
  coord_flip() + theme_void() +
  scale_fill_distiller(palette = "Reds", direction=1)
        

Fig1 + gg.spp 
  
# Change relative grid sizes
library(grid)
library(gtable)

gt = ggplot_gtable(ggplot_build(Fig1))
gt$layout$l[grep('panel-3', gt$layout$name)] # you want to find the column specific to panel-2

gt$widths[9] = 0.3*gt$widths[9] # reduce width of column 9
grid.draw(gt) # plot with grid draw

```


# Community assembly


## Neutral model

```{r Neutral model}
library(reltools)
library(minpack.lm)
library(Hmisc)

# Fit neutral model
spp <- otu_table(ps2)@.Data
spp.out <- fit_sncm(spp, pool=spp, taxon=data.frame(tax_table(ps.neutral)))

## Neutral model through time
#Set slices
slices=seq(0,1.6,0.1)
 sampleOTUs = t(otu_table(ps2))

neutral <- NMTT(similarity_slices = slices, sampleOTUs = otu_table(ps2), tree = phy_tree(ps2), quiet = FALSE, return="summary")
  
ggplot(test, aes(x=slice, y=freq, fill=fit_class)) + 
      geom_bar(stat="identity")
```

## Phylogenetic community assembly

n order to further test this notion and to assess how environmental filtering may differ among host clades, we utilized two ecophylogenetics analyses: mean phylogenetic distance (MPD) and mean nearest taxon distance (MNTD). These tests assess the degree of phylogenetic clustering within each sample (host) relative to a permuted null model. Assuming phylogenetic niche conservatism (i.e., closely related taxa overlap along niche axes), then host diet or gut physiology may select for phylogenetically clustered taxa with overlapping niches, while in the absence of such strong selection, competition via niche conservatism would lead to phylogenetic overdispersion40. Phylogenetic overdispersion may also result from facilitation (i.e., beneficial microbe–microbe interactions), such as when distantly related taxa form consortia to break down complex plant polymers40. MPD is more sensitive to overall patterns of phylogenetic clustering and evenness, while MNTD is more sensitive to patterns at the tree tips41.

```{r phylogenetic community assembly}
phy <- phyloseq::phy_tree(ps2)
comm <- as(phyloseq::otu_table(ps2), "matrix") 

## Need to do these with rarified samples as well! 

# Calculate Faith's PD-index	
pdtable <- picante::pd(comm, phy, include.root = F)	

# Calculate Faith's PD-index with SES	
sespd <- picante::ses.pd(comm, phy, null.model = "taxa.labels", include.root = F, runs = 99) %>% 
  rownames_to_column("Sample.Name") %>%
  left_join(read.csv("sample_data/Sample_info.csv", header=TRUE)  %>%
  dplyr::filter(!duplicated(SampleID)) %>%
  set_rownames(.$SampleID), by = "Sample.Name") 

# Weighted NTI
library(picante)
phydist <- cophenetic(phy)

weightedNTI <- picante::ses.mpd(comm, phydist, null.model = "taxa.labels", abundance.weighted = TRUE, runs = 99) %>% 
  rownames_to_column("Sample.Name") %>%
  left_join(read.csv("sample_data/Sample_info.csv", header=TRUE)  %>%
  dplyr::filter(!duplicated(SampleID)) %>%
  set_rownames(.$SampleID), by = "Sample.Name") %>%
  mutate(NTI = mpd.obs.z *-1)

ggplot(weightedNTI, aes(x=psyllid_spp, y=NTI, group=psyllid_spp)) + 
  geom_boxplot() +
  geom_point() +
  theme(axis.text.x = element_text(angle=90)) + 
  ggtitle("Weighted NTI by psyllid family")

# Mean Weighted NTI
mean(weightedNTI$NTI)

#Unweighted NTI
unweightedNTI <- picante::ses.mpd(comm, phydist, null.model = "taxa.labels", abundance.weighted = FALSE, runs = 99) %>% 
  rownames_to_column("Sample.Name") %>%
  left_join(read.csv("sample_data/Sample_info.csv", header=TRUE)  %>%
  dplyr::filter(!duplicated(SampleID)) %>%
  set_rownames(.$SampleID), by = "Sample.Name") %>%
  mutate(NTI = mpd.obs.z *-1)

ggplot(unweightedNTI, aes(x=psyllid_spp, y=NTI, group=psyllid_spp)) + 
  geom_boxplot() +
  geom_point() +
  theme(axis.text.x = element_text(angle=90)) + 
  ggtitle("Unweighted NTI by psyllid family")

# Mean uneighted NTI
mean(unweightedNTI$NTI)

# Weighted NRI
weightedNRI <- picante::ses.mntd(comm, phydist, null.model = "taxa.labels", abundance.weighted = TRUE, runs = 99) %>% 
  rownames_to_column("Sample.Name") %>%
  left_join(read.csv("sample_data/Sample_info.csv", header=TRUE)  %>%
  dplyr::filter(!duplicated(SampleID)) %>%
  set_rownames(.$SampleID), by = "Sample.Name") %>%
  mutate(NRI = mntd.obs.z *-1)

ggplot(weightedNRI, aes(x=psyllid_spp, y=NRI, group=psyllid_spp)) + 
  geom_boxplot() +
  geom_point() +
  theme(axis.text.x = element_text(angle=90)) + 
  ggtitle("Weighted by psyllid family")

# Mean Weighted NRI
mean(weightedNRI$NRI)

# Unweighted NRI
unweightedNRI <- picante::ses.mntd(comm, phydist, null.model = "taxa.labels", abundance.weighted = FALSE, runs = 99) %>% 
  rownames_to_column("Sample.Name") %>%
  left_join(read.csv("sample_data/Sample_info.csv", header=TRUE)  %>%
  dplyr::filter(!duplicated(SampleID)) %>%
  set_rownames(.$SampleID), by = "Sample.Name") %>%
    mutate(NRI = mntd.obs.z *-1) 

ggplot(unweightedNRI, aes(x=psyllid_spp, y=NRI, group=psyllid_spp)) + 
  geom_boxplot() +
  geom_point() +
  theme(axis.text.x = element_text(angle=90)) + 
  ggtitle("Weighted by psyllid family")

# Mean Weighted NRI
mean(unweightedNRI$NRI)

library(phylosignal)	
library(adephylo)	
#alpha diversity data	
dat <- list()	

dat$ba_alpha <-  bt_randomdf %>%	
  filter(psyllid_spp %in% pruned.tree$tip.label) %>%	
  arrange(match(psyllid_spp, pruned.tree$tip.label)) %>%	
  pull(Estimates)	

dat$alpha <-  sespd %>%	
  filter(psyllid_spp %in% pruned.tree$tip.label) %>%	
  group_by(psyllid_spp) %>%
  summarise(ntaxa = mean(ntaxa)) %>%
  arrange(match(psyllid_spp, pruned.tree$tip.label)) %>%	
  pull(ntaxa)	

dat$pd_obs <-  sespd %>%	
  filter(psyllid_spp %in% pruned.tree$tip.label) %>%	
  group_by(psyllid_spp) %>%
  summarise(pd.obs = mean(pd.obs)) %>%
  arrange(match(psyllid_spp, pruned.tree$tip.label)) %>%	
  pull(pd.obs)	

dat$pd_obsz <-  sespd %>%	
  filter(psyllid_spp %in% pruned.tree$tip.label) %>%	
  group_by(psyllid_spp) %>%
  summarise(pd.obs.z = mean(pd.obs.z)) %>%
  arrange(match(psyllid_spp, pruned.tree$tip.label)) %>%	
  pull(pd.obs.z)	

dat$weighted_nti <- weightedNTI   %>%	
  filter(psyllid_spp %in% pruned.tree$tip.label) %>%	
  group_by(psyllid_spp) %>%
  summarise(NTI = mean(NTI)) %>% # Get mean for each species
  arrange(match(psyllid_spp, pruned.tree$tip.label)) %>%	
  pull(NTI)	

dat$unweighted_nti <- unweightedNTI   %>%	
  filter(psyllid_spp %in% pruned.tree$tip.label) %>%	
  group_by(psyllid_spp) %>%
  summarise(NTI = mean(NTI)) %>% # Get mean for each species
  arrange(match(psyllid_spp, pruned.tree$tip.label)) %>%	
  pull(NTI)	

dat$weighted_nri <- weightedNRI   %>%	
  filter(psyllid_spp %in% pruned.tree$tip.label) %>%	
  group_by(psyllid_spp) %>%
  summarise(NRI = mean(NRI)) %>% # Get mean for each species
  arrange(match(psyllid_spp, pruned.tree$tip.label)) %>%	
  pull(NRI)	

dat$unweighted_nri <- unweightedNRI   %>%	
  filter(psyllid_spp %in% pruned.tree$tip.label) %>%	
  group_by(psyllid_spp) %>%
  summarise(NRI = mean(NRI)) %>% # Get mean for each species
  arrange(match(psyllid_spp, pruned.tree$tip.label)) %>%	
  pull(NRI)	

dat$random <- rnorm(length(dat$alpha), sd = 10) # Negative control - random association
dat$bm <- rTraitCont(pruned.tree) #Positive control - Brownian motion
dat <- as.data.frame(dat)	

# Make phylosignal object and measure signal between univariate traits.
p4d <- phylobase::phylo4d(pruned.tree, dat)	
phyloSignal(p4d = p4d, method = "all")	

# Plots
barplot.phylo4d(p4d, tree.type = "phylo", tree.ladderize = TRUE)

correl <- vector("list", length=length(dat))
for (i in 1:length(dat)) {
  correl[[i]] <- phyloCorrelogram(p4d, trait = names(dat[i]))
  plot(correl[[i]], main= names(dat[i]))
}

# Locate signal
lipa <- lipaMoran(p4d)
lipa.p4d <- lipaMoran(p4d, as.p4d = TRUE)

barplot.phylo4d(p4d, bar.col=(lipa$p.value < 0.05) + 1, center = FALSE , scale = FALSE)

barplot.phylo4d(lipa.p4d, bar.col = (lipa$p.value < 0.05) + 1, center = FALSE, scale = FALSE)

# Asses modelbehavior	
phylosim <- phyloSim(tree = pruned.tree, method = "all", nsim = 100, reps = 99)	
plot.phylosim(phylosim, what = "pval", stacked.methods = TRUE)	
```	


RESULTS: while there were significant differences between psyllid species (see betta results), there were no significant associations with phylogeny

Would be better to integrate this with a phylogenetic glmm - see mcmc.OTU package


# Phylosymbiosis

## Figure 2 - BDTT 

```{r timeslice}
library(ape)
library(castor)
library(abind)
library(Matrix)

## TRY WITHOUT ENTERO
#ps2 <- ps2 %>%
#  subset_taxa(Family  != "Enterobacteriaceae") %>%
#  filter_taxa(function(x) mean(x) > 0, TRUE)#Drop missing taxa from table
#
#ps2 <- prune_samples(sample_sums(ps2) >0 , ps2)
#Look at depth categories in tree
hist(get_all_node_depths(phy_tree(ps2)))

#Set slices
slices=seq(0,1.6,0.01)

#Plot trees at slices
treelist <- vector("list", length=length(slices))
for (i in 1:length(slices)){
  newtree <- collapse_tree_at_resolution(phy_tree(ps2),slices[i], shorten = TRUE)$tree
  treelist[[i]] <- newtree
}

class(treelist) <- "multiPhylo"
names(treelist) <- paste0("Timeslice = ",slices)
gg.tree <- ggtree(treelist) + facet_wrap(~.id, scale="free", nrow=1) + theme_tree2()

#Conduct slices and calculate beta diversity
Betas=BDTT(similarity_slices = slices, tree = phy_tree(ps2), sampleOTUs = t(otu_table(ps2)), metrics=c("Bray","Jaccard","Aitchison","Philr", "Unifrac", "WUnifrac"), zeroes="Impute", parallel=FALSE, quiet=FALSE)
```

### Prepare distance matrices
```{r prepare distances}
## Make distance matrices
# COI Genetic distance
phylo.dist <- read_csv("sample_data/genetic_distance.csv", col_names = TRUE) %>%
  column_to_rownames("SampleID") 

phylo.dist[upper.tri(phylo.dist)] <- 0
phylo.dist <- phylo.dist + t(phylo.dist)
phylo.dist[is.na(phylo.dist)] <- 0

phylo.dist <- phylo.dist %>%
  set_colnames(rownames(.) %>% str_replace(pattern="\\_S(.*)$",replacement="") %>% make.unique()) %>%
  rownames_to_column("SampleID") %>%
  mutate(SampleID = SampleID %>% str_replace(pattern="\\_S(.*)$",replacement="") %>% make.unique()) %>%
  #filter(SampleID %in% rownames(as.matrix(coda.dist))) %>%
  #arrange(match(SampleID, colnames(as.matrix(coda.dist)))) %>%
  column_to_rownames("SampleID") %>%
  #dplyr::select(one_of(colnames(as.matrix(coda.dist)))) %>%
  as.matrix()

# Hostplant distance
plant.dist <- read_csv("sample_data/plant_distance.csv") %>%
  dplyr::select(-one_of("X1", "Host plants")) %>%
  column_to_rownames("SampleID") %>%
  set_colnames(rownames(.) %>% str_replace(pattern="\\_S(.*)$",replacement="") %>% make.unique()) %>%
  rownames_to_column("SampleID") %>%
  mutate(SampleID = SampleID %>% str_replace(pattern="\\_S(.*)$",replacement="") %>% make.unique()) %>%
  #filter(SampleID %in% rownames(as.matrix(comm.dist))) %>%
  #arrange(match(SampleID, colnames(as.matrix(comm.dist)))) %>%
  column_to_rownames("SampleID") %>%
  #dplyr::select(one_of(colnames(as.matrix(comm.dist)))) %>%
  as.matrix()

# Spatial distance
envData <- read.csv("sample_data/Sample_info.csv", header=TRUE)  %>%
  dplyr::filter(!duplicated(SampleID)) %>%
  set_rownames(.$SampleID) %>%
  separate(Collection, into= c("Lat", "Long"), sep=" ", remove = FALSE) %>%
  separate(Lat, paste("lat",c("d","m","s"), sep="_") ) %>%
  separate(Long, paste("long",c("d","m","s"), sep="_" ) ) %>%
  mutate_at(vars(-SampleID, -psyllid_spp), funs(as.numeric)) %>%
  mutate(lat=-(lat_d + lat_m/60 + lat_s/60^2),
            long=long_d + long_m/60 + long_s/60^2) %>%
  dplyr::select(SampleID, psyllid_spp, lat, long) %>%
  column_to_rownames("SampleID") %>%
  drop_na()

#Make spatial distance matrix
spat.dist <- spDists(as.matrix(envData %>% dplyr::select(-psyllid_spp)), longlat=TRUE) %>%
  as.data.frame() %>%
  set_rownames(rownames(envData) %>% str_replace(pattern="\\_S(.*)$",replacement="") %>% make.unique()) %>%
  set_colnames(rownames(envData) %>% str_replace(pattern="\\_S(.*)$",replacement="") %>% make.unique()) %>%
  rownames_to_column("SampleID") %>%
  mutate(SampleID = SampleID %>% str_replace(pattern="\\_S(.*)$",replacement="") %>% make.unique()) %>%
  #filter(SampleID %in% rownames(as.matrix(comm.dist))) %>%
  #arrange(match(SampleID, colnames(as.matrix(comm.dist)))) %>%
  column_to_rownames("SampleID") %>%
  #dplyr::select(one_of(colnames(as.matrix(comm.dist)))) %>%
  as.matrix()
```

### Adonis tests
```{r Adonis}
# Construct sequence table

predictors="psyllid_spp"
StatsRes=expand.grid(similarity_slices=as.character(slices), predictors=predictors, metric=dimnames(Betas)[[2]])
StatsRes[["F.Model"]]=StatsRes[["R2"]]=StatsRes[["Pr(>F)"]]=NA
head(StatsRes)

samples <- rownames(otu_table(ps2)) 
metadata <- sample_data(ps2) %>%
  as_data_frame()

# Generalise to work with multiple predictors

for (i in as.character(slices)){
  #Jaccard
  res=unlist(adonis(Betas[i,"Jaccard",samples,samples]~ psyllid_spp, method = "euclidean", data = metadata)$aov.tab[1,c(6,5,4)])
  StatsRes[(StatsRes$metric=="Jaccard")&(StatsRes$similarity_slices==i),4:6]=res
  #Bray Curtis
  res=unlist(adonis(Betas[i,"Bray",samples,samples]~ psyllid_spp, method = "euclidean", data = metadata)$aov.tab[1,c(6,5,4)])
  StatsRes[(StatsRes$metric=="Bray")&(StatsRes$similarity_slices==i),4:6]=res
  #Aitchison
  res=unlist(adonis(Betas[i,"Aitchison",samples,samples]~ psyllid_spp, method = "euclidean", data = metadata)$aov.tab[1,c(6,5,4)])
  StatsRes[(StatsRes$metric=="Aitchison")&(StatsRes$similarity_slices==i),4:6]=res
  #Philr
  res=unlist(adonis(Betas[i,"Philr",samples,samples]~ psyllid_spp, method = "euclidean", data = metadata)$aov.tab[1,c(6,5,4)])
  StatsRes[(StatsRes$metric=="Philr")&(StatsRes$similarity_slices==i),4:6]=res
  #Unifrac
  res=unlist(adonis(Betas[i,"Unifrac",samples,samples]~ psyllid_spp, method = "euclidean", data = metadata)$aov.tab[1,c(6,5,4)])
  StatsRes[(StatsRes$metric=="Unifrac")&(StatsRes$similarity_slices==i),4:6]=res
  #WUnifrac
  res=unlist(adonis(Betas[i,"WUnifrac",samples,samples]~ psyllid_spp, method = "euclidean", data = metadata)$aov.tab[1,c(6,5,4)])
  StatsRes[(StatsRes$metric=="WUnifrac")&(StatsRes$similarity_slices==i),4:6]=res
}


# Profile for all
ggplot(StatsRes, aes(y=R2, x=similarity_slices, colour=predictors, group=factor(predictors)))+
  geom_point() +
  geom_line() +
  facet_wrap(~metric)

```

### Mantel tests
```{r Mantel} 
samples <- rownames(otu_table(ps2))
dists <- c("phylo.dist","plant.dist", "spat.dist")
mantlist_distances <- vector("list", length=length(dists))

# Generalise these to a function. Get names from the slices object

for (d in 1:length(dists)){
  test.dist <- get(dists[d])

  samples_to_use <- samples[samples %in% colnames(as.matrix(test.dist))]
  
  manlist <- vector("list", length=length(slices))
  for (i in 1:length(slices)){
    
    nslice <- as.character(slices[i])
    #Jac
    man_jac <- mantel(Betas[nslice,"Jaccard",samples_to_use,samples_to_use], test.dist[samples_to_use,samples_to_use])
    #Bray
    man_bray<- mantel(Betas[nslice,"Bray",samples_to_use,samples_to_use], test.dist[samples_to_use,samples_to_use])
    #Aitch
    man_aitch <- mantel(Betas[nslice,"Aitchison",samples_to_use,samples_to_use], test.dist[samples_to_use,samples_to_use])
    #PhilR
    man_philr <- mantel(Betas[nslice,"Philr",samples_to_use,samples_to_use], test.dist[samples_to_use,samples_to_use])
    #Unifrac
    man_unifrac <- mantel(Betas[nslice,"Unifrac",samples_to_use,samples_to_use], test.dist[samples_to_use,samples_to_use])
    #Weighted Unifrac
    man_wunifrac <- mantel(Betas[nslice,"WUnifrac",samples_to_use,samples_to_use], test.dist[samples_to_use,samples_to_use])

    manlist[[i]] <- tribble(
      ~metric, ~stat, ~signif,
      "Jaccard (Qualitative)", man_jac$statistic, man_jac$signif,
      "Bray-Curtis(Quantitative)", man_bray$statistic, man_bray$signif,
      "Aitchison (Quantitative, Compositional)", man_aitch$statistic, man_aitch$signif,
      "PhilR (Quantitative, Phylogenetic, Compositional)", man_philr$statistic, man_philr$signif,
      "Unifrac (Qualitative, Phylogenetic)", man_unifrac$statistic, man_unifrac$signif,
      "Weighted Unifrac (Quantitative, Phylogenetic)", man_wunifrac$statistic, man_wunifrac$signif
    ) %>%
      mutate(distance=dists[d], slice=slices[i])
  }
  mantlist_distances[[d]] <- bind_rows(manlist)
}

gg.mantel <- bind_rows(mantlist_distances) %>%
  mutate(Comparison = paste0("microbe~",distance)) %>%
  ggplot(aes(y=stat,x=slice, colour=distance, group=factor(distance))) +
  geom_path(linetype="dashed")+
  geom_line(data=bind_rows(mantlist_distances) %>% mutate(stat = case_when (signif > 0.01 ~ as.double(NA), signif < 0.01 ~ stat)), linetype="solid") +
  geom_hline(yintercept=0) +
  facet_wrap(~metric) +
     theme_classic2()   +
     theme(legend.position = "right",
           panel.grid.major.y = element_line(colour="grey", size=0.5, linetype="dashed"),
           strip.background = element_rect(fill = "grey92", 
                                           colour = "black", size = 1)
     )  + scale_color_brewer(palette="Paired")
```

### Partial mantel tests
```{r Partial Mantel}
samples <- rownames(otu_table(ps2))
dists <- expand_grid(dist1 = c("phylo.dist","plant.dist", "spat.dist"), dist2=c("phylo.dist","plant.dist", "spat.dist")) %>%
  filter(!dist1==dist2)
PMlist_distances <- vector("list", length=length(dists))

for (d in 1:nrow(dists)){
  test.dist <- get(dists$dist1[d])
  control.dist <- get(dists$dist2[d])
  
  samples_to_use <- samples[samples %in% colnames(as.matrix(test.dist))]
  samples_to_use <- samples_to_use[samples_to_use %in% colnames(as.matrix(control.dist))]
  
  PMlist <- vector("list", length=length(slices))
  for (i in 1:length(slices)){
    
    nslice <- as.character(slices[i])
    #Jac
    PM_jac <- mantel.partial(Betas[nslice, "Jaccard", samples_to_use, samples_to_use],
                         test.dist[samples_to_use, samples_to_use],
                          control.dist[samples_to_use, samples_to_use])
    
    #Bray
    PM_bray <- mantel.partial(Betas[nslice,"Bray",samples_to_use,samples_to_use],
                         test.dist[samples_to_use,samples_to_use],
                         control.dist[samples_to_use,samples_to_use])
    #Aitch
    PM_aitch <- mantel.partial(Betas[nslice,"Aitchison",samples_to_use,samples_to_use], 
                         test.dist[samples_to_use,samples_to_use], 
                         control.dist[samples_to_use,samples_to_use])
    #Philr
    PM_philr <- mantel.partial(Betas[nslice,"Philr",samples_to_use,samples_to_use], 
                         test.dist[samples_to_use,samples_to_use], 
                         control.dist[samples_to_use,samples_to_use])
    #Unifrac
    PM_unifrac <- mantel.partial(Betas[nslice,"Unifrac",samples_to_use,samples_to_use], 
                         test.dist[samples_to_use,samples_to_use], 
                         control.dist[samples_to_use,samples_to_use])
    #Weighted Unifrac
    PM_wunifrac <- mantel.partial(Betas[nslice,"WUnifrac",samples_to_use,samples_to_use], 
                         test.dist[samples_to_use,samples_to_use], 
                         control.dist[samples_to_use,samples_to_use])
    PMlist[[i]] <- tribble(
      ~metric, ~stat, ~signif,
      "Jaccard (Qualitative)", PM_jac$statistic, PM_jac$signif,
      "Bray (Quantitative)", PM_bray$statistic, PM_bray$signif,
      "Aitchison (Quantitative, Compositional)", PM_aitch$statistic, PM_aitch$signif,
      "PhilR (Quantitative, Phylogenetic, Compositional)", PM_philr$statistic, PM_philr$signif,
      "Unifrac (Qualitative, Phylogenetic)", PM_unifrac$statistic, PM_unifrac$signif,
      "Weighted Unifrac (Quantitative, Phylogenetic)", PM_wunifrac$statistic, PM_wunifrac$signif
    ) %>%
      mutate(dist1=dists$dist1[d], dist2=dists$dist2[d], slice=slices[i])
    }
  PMlist_distances[[d]] <- bind_rows(PMlist)
}


gg.pmantel <- bind_rows(PMlist_distances) %>%
  mutate(Comparison = paste0("microbe~",dist1,"~",dist2)) %>%
  ggplot(aes(y=stat, x=slice, colour=Comparison, group=factor(Comparison)))+ 
  geom_line(linetype="dashed") +
  geom_line(data=bind_rows(PMlist_distances) %>% mutate(Comparison = paste0("microbe~",dist1,"~",dist2)) %>% mutate(stat = case_when (signif > 0.01 ~ as.double(NA), signif < 0.01 ~ stat)), linetype="solid") +
  geom_hline(yintercept=0) +
  facet_wrap(~metric) +
     theme_classic2()   +
     theme(legend.position = "right",
           panel.grid.major.y = element_line(colour="grey", size=0.5, linetype="dashed"),
           strip.background = element_rect(fill = "grey92", 
                                           colour = "black", size = 1)
     )  + scale_color_brewer(palette="Paired")

```


### Procrustes tests
```{r Procrustes}
samples <- rownames(otu_table(ps2))
dists <- c("phylo.dist","plant.dist", "spat.dist")
proc_distances <- vector("list", length=length(dists))

for (d in 1:length(dists)){
  test.dist <- get(dists[d])
  
  samples_to_use <- samples[samples %in% colnames(as.matrix(test.dist))]
  
  proclist <- vector("list", length=length(slices))
  for (i in 1:length(slices)){
    
      
    nslice <- as.character(slices[i])
    #Jac
    proc_jac <- protest(monoMDS(Betas[nslice,"Jaccard",samples_to_use,samples_to_use]), monoMDS(test.dist[samples_to_use,samples_to_use])) 
    #Bray
    proc_bray <- protest(monoMDS(Betas[nslice,"Bray",samples_to_use,samples_to_use]), monoMDS(test.dist[samples_to_use,samples_to_use])) 
    #Aitch
    proc_aitch <- protest(monoMDS(Betas[nslice,"Aitchison",samples_to_use,samples_to_use]), monoMDS(test.dist[samples_to_use,samples_to_use]))
    #PhilR
    proc_philr <- protest(monoMDS(Betas[nslice,"Philr",samples_to_use,samples_to_use]), monoMDS(test.dist[samples_to_use,samples_to_use]))
    #Unifrac
    proc_unifrac <- protest(monoMDS(Betas[nslice,"Unifrac",samples_to_use,samples_to_use]), monoMDS(test.dist[samples_to_use,samples_to_use]))
    #Weighted Unifrac
    proc_wunifrac <- protest(monoMDS(Betas[nslice,"WUnifrac",samples_to_use,samples_to_use]), monoMDS(test.dist[samples_to_use,samples_to_use]))

    proclist[[i]] <- tribble(
      ~metric, ~stat, ~scale, ~signif,
      "Jaccard (Qualitative)", proc_jac$t0, proc_jac$scale, proc_jac$signif,
      "Bray-Curtis(Quantitative)", proc_bray$t0, proc_bray$scale, proc_bray$signif,
      "Aitchison (Quantitative, Compositional)", proc_aitch$t0, proc_aitch$scale, proc_aitch$signif,
      "PhilR (Quantitative, Phylogenetic, Compositional)", proc_philr$t0, proc_philr$scale, proc_philr$signif,
      "Unifrac (Qualitative, Phylogenetic)", proc_unifrac$t0, proc_unifrac$scale, proc_unifrac$signif,
      "Weighted Unifrac (Quantitative, Phylogenetic)", proc_wunifrac$t0, proc_wunifrac$scale, proc_wunifrac$signif
    ) %>%
      mutate(distance=dists[d], slice=slices[i])
  }
  proc_distances[[d]] <- bind_rows(proclist)
}


gg.proc <- bind_rows(proc_distances) %>%
  mutate(Comparison = paste0("microbe~",distance)) %>%
  ggplot(aes(y=stat,x=slice, colour=distance, group=factor(distance))) +
  geom_path(linetype="dashed")+
  geom_line(data=bind_rows(mantlist_distances) %>% mutate(stat = case_when (signif > 0.01 ~ as.double(NA), signif < 0.01 ~ stat)), linetype="solid") +
  geom_hline(yintercept=0) +
  facet_wrap(~metric) +
     theme_classic2()   +
     theme(legend.position = "right",
           panel.grid.major.y = element_line(colour="grey", size=0.5, linetype="dashed"),
           strip.background = element_rect(fill = "grey92", 
                                           colour = "black", size = 1)
     )  + scale_color_brewer(palette="Paired")

gg.proc <- bind_rows(proc_distances) %>%
  mutate(Significance = case_when(
    signif < 0.01 ~ TRUE,
    signif > 0.01 ~ FALSE
  ), Comparison = paste0("microbe~",distance)) %>%
  ggplot(aes(y=stat,x=slice, colour=distance, group=factor(distance)))+
  geom_point(aes(shape=Significance)) +
  geom_line()+ 
  geom_hline(yintercept=0) +
  facet_wrap(~metric) +
     theme_classic2()   +
     theme(legend.position = "right",
           panel.grid.major.y = element_line(colour="grey", size=0.5, linetype="dashed"),
           strip.background = element_rect(fill = "grey92", 
                                           colour = "black", size = 1)
     )

```


### Tree topology comparison

Heirarchial clustering 
robinson foulds, matching cluster

But also see how this paper has done it with PACO https://www.nature.com/articles/s41467-019-10191-3.pdf Using random subsampling? Then pull out the most associated also file:///C:/Users/ap0y/Dropbox/workprojects/Papers/10.1002_ecy.1955.pdf
```{r topology comparison}
samples <- rownames(otu_table(ps2))
dists <- c("phylo.dist","plant.dist", "spat.dist")
mantlist_distances <- vector("list", length=length(dists))

for (d in 1:length(dists)){
  test.dist <- get(dists[d])
  
  samples_to_use <- samples[samples %in% colnames(as.matrix(test.dist))]
  
  manlist <- vector("list", length=length(slices))
  for (i in 1:length(slices)){
    
    nslice <- as.character(slices[i])
    #Jac
    hc <- (as.phylo(hclust(as.dist(Betas[nslice,"Jac",samples_to_use,samples_to_use]), method="ward.D2")))
    
    # random tree
    rtree(length(hc$tip.label), rooted=FALSE)
    
    
    dist.topo(as.phylo(hclust(as.dist(Betas[nslice,"Jac",samples_to_use,samples_to_use]), method="ward.D2"), directed=FALSE),
              y = as.phylo(hclust(as.dist(test.dist[samples_to_use,samples_to_use]), method="ward.D2")), method = "PH85")
    
    dist.topo(as.phylo(hclust(as.dist(Betas[nslice,"Jac",samples_to_use,samples_to_use]), method="ward.D2")),
              y = as.phylo(hclust(as.dist(test.dist[samples_to_use,samples_to_use]), method="ward.D2")), method = "PH85")

    
    proc <- protest(monoMDS(Betas[nslice,"Jac",samples_to_use,samples_to_use]), monoMDS(test.dist[samples_to_use,samples_to_use]))
    proc_jac <- data.frame(metric="Jac", test=dists[d], stat=proc$t0, scale=proc$scale, signif=proc$signif)
    #Bray
    proc <- protest(monoMDS(Betas[nslice,"Bray",samples_to_use,samples_to_use]), monoMDS(test.dist[samples_to_use,samples_to_use]))
    proc_bray <- data.frame(metric="Bray", test=dists[d], stat=proc$t0, scale=proc$scale, signif=proc$signif)
    #Aitch_psedo
    proc <- protest(monoMDS(Betas[nslice,"Aitch_pseudo",samples_to_use,samples_to_use]), monoMDS(test.dist[samples_to_use,samples_to_use]))
    proc_aitch_pseudo <- data.frame(metric="Aitch_pseudo", test=dists[d], stat=proc$t0, scale=proc$scale, signif=proc$signif)
    #Aitch_rep
    proc <- protest(monoMDS(Betas[nslice,"Aitch_pseudo",samples_to_use,samples_to_use]), monoMDS(test.dist[samples_to_use,samples_to_use]))
    proc_aitch_rep <- data.frame(metric="Aitch_rep", test=dists[d], stat=proc$t0, scale=proc$scale, signif=proc$signif)
    manlist[[i]] <- bind_rows(proc_jac, proc_bray, proc_aitch_pseudo, proc_aitch_rep) %>%
      mutate(slice=slices[i])
  }
  mantlist_distances[[d]] <- bind_rows(manlist)
}

matrix_stats <- bind_rows(mantlist_distances) %>%
  mutate(signif_test = case_when(
    signif < 0.01 ~ TRUE,
    signif > 0.01 ~ FALSE
  ))
gg.mantel <- ggplot(matrix_stats, aes(y=stat,x=slice, colour=test, group=factor(test)))+
  geom_point(aes(shape=signif_test)) +
  geom_line()+ 
  geom_hline(yintercept=0) +
  facet_wrap(~metric) 


```

# Cophylogeny


## Psyllid hostplant cophylogeny

```{r}


```

## Cophylogeny over Phylogenetic scale


```{r randomtapas}
## Prepare interaction table
# Merge species
ps.sppmerged <- ps2 %>%
    merge_samples(group = "psyllid_spp")

sample_data(ps.sppmerged) <- read.csv("sample_data/Sample_info.csv", header=TRUE) %>%
  filter(!duplicated(psyllid_spp)) %>%
  set_rownames(.$psyllid_spp) %>%
  dplyr::select(c("SampleID", "Sample.Name", "seqrun", "psyllid_spp", "psyllid_genus", "psyllid_family", "hostplant_spp","Collection","Collection.Date"))

# subset to just carsonella
ps.sppmerged <- ps.sppmerged %>%
  subset_taxa( Genus == "Candidatus_Carsonella"
  )

ps4 <- filter_taxa(ps.sppmerged, function(x) mean(x) > 0, TRUE) #Drop missing taxa from table

#Rename taxa
taxa_names(ps4) <- paste0("SV", seq(ntaxa(ps4)),"-",tax_table(ps4)[,6])

#rename problem samples
sample_names(ps4) <- sample_names(ps4) %>% str_replace_all("'","")

otu <- ps4 %>%
    otu_table %>%
    as.matrix() %>% 
  apply(2, function(x) ifelse(x > 0, 1, 0))

                  
#Cophenetic distance
psyllid_tree <- read.tree(text=readLines("sample_data/psyllid_beast_tree.nwk"))

# Match names with alpha diversity
psyllid_tree$tip.label <- psyllid_tree$tip.label %>%
  str_replace_all(pattern="\\.", replacement=" ") %>%
  str_replace_all(pattern="sp$", replacement="sp. ") %>%
  str_replace_all(pattern="Acizzia hakae", replacement="Acizzia hakeae") %>%
  str_replace_all(pattern="POLLENISLAND", replacement="POLLEN ISLAND") %>%
  str_replace_all(pattern="Ctenarytaina fuchsiae$", replacement="Ctenarytaina fuchsia A") %>%
  str_replace_all(pattern="Ctenarytaina fuchsiaeB", replacement="Ctenarytaina fuchsia B") %>%
  str_replace_all(pattern="Ctenarytaina fuchsiaeC", replacement="Ctenarytaina fuchsia C") %>%
  str_replace_all(pattern="Ctenarytaina clavata", replacement="Ctenarytaina clavata sp. ") %>%
  str_replace_all(pattern="Ctenarytaina clavata sp. $", replacement="Ctenarytaina clavata sp. A") %>%
  str_replace_all(pattern="Ctenarytaina sp$", replacement="Ctenarytaina sp. ") %>%
  str_replace_all(pattern="Ctenarytaina unknown", replacement="Ctenarytaina insularis") %>%  
  str_replace_all(pattern="Psylla apicalis A", replacement="Psylla frodobagginsi") %>%
  str_replace_all(pattern="Psylla apicalis B", replacement="Psylla apicalis") %>%
  str_replace_all(pattern="carmichaeliae", replacement="carmichaeliae ") %>%
  str_replace_all(pattern="Psylla apicalis", replacement="Psylla apicalis ") %>% # Should these be A,B or?
  str_replace_all(pattern="Trioza sp", replacement="Trioza sp. ") %>%
  str_replace_all(pattern="Trioza acutaB", replacement="Trioza Acuta B") %>%
  str_replace_all(pattern="BRENDAMAY", replacement="BRENDA MAY") %>%
  str_replace_all(pattern="PRICES", replacement="PRICES VALLEY") %>%
  trimws(which="right")

psyllid_tree$tip.label[!psyllid_tree$tip.label %in% rownames(otu)]

pruned.tree <- drop.tip(psyllid_tree, psyllid_tree$tip.label[!psyllid_tree$tip.label %in% rownames(otu)] )
psyllid_tree$tip.label[!psyllid_tree$tip.label %in%  pruned.tree$tip.label]

#cophenetic <- cophenetic(pruned.tree)

HS <- otu[pruned.tree$tip.label,]
TreeH <- pruned.tree
TreeS <- phy_tree(ps4)

# Optional: Draw a tanglegram

HS.lut <- which(HS ==1, arr.ind=TRUE)
linkhs <- cbind(rownames(HS)[HS.lut[,1]], colnames(HS)[HS.lut[,2]])
obj <- cophylo(tr1=TreeH, tr2=TreeS, assoc=linkhs, rotate=TRUE) 
plot.cophylo(obj, link.lwd=1, link.lty=2, fsize=0.5, pts=FALSE, link.type="curved")
dev.off() #reset graphics device



# 1. Find minimum value with which all runs can be completed - Establish N
#Recommended= N= 1e+4
N= 100
One2one.f(HS,N) 

# N should be close	to	20%,	or	at	least	10%,	of	the	total	number	of	associations
# For our dataset number of associations = (length(TreeS$tip.label)) = 3042 * 0.2 = 608.4 
# We can evaluate a range if we want
X <- seq(10,50,5)
Y <- rep(NA, length(X))
for(i in 1:length(X)) {
  THS <- trimHS.maxC(N, HS, n=X[i], check.unique=TRUE)
  Y[i] <- length(THS)
}
plot(X,Y, type="b", xlab="Number of unique H-S associations",
     ylab="Number of runs accomplished")
# 3. We choose 8
n=50
THS <- trimHS.maxC(N, HS, n=n, check.unique=TRUE)
THS[sapply(THS, is.null)] <- NULL

####### Apply 2 global-fit methods: GD and PACo ##########
# NOTE PACo symmetric= TRUE in this example!!!!
GD <- sapply(THS, geo.D, treeH=TreeH, treeS= TreeS)
PACO <- sapply(THS, paco.ss, treeH=TreeH, treeS= TreeS, ei.correct= "sqrt.D",
               symmetric=TRUE)
#
######### extract h-s association frequencies
LFGD01 <- link.freq(THS, GD, HS, percentile=0.01)
LFPACO01 <- link.freq(THS, PACO, HS, percentile=0.01)
#
```

Use paco https://besjournals.onlinelibrary.wiley.com/doi/full/10.1111/2041-210X.12736

and Parafit https://www.rdocumentation.org/packages/ape/versions/5.3/topics/parafit

```{r paco}

## Plotting - arrange by tree

## Paco needs:

## Co-occurance matrix
# otu abundance matrix
ps2.glom <- ps2 %>% 
    tip_glom(h=0.3)

otu <- ps2.glom %>%
    otu_table %>%
    as.data.frame %>%
    rownames_to_column("SampleID") %>%
    filter(SampleID %in% rownames(host_dist)) %>%
    arrange(match(SampleID, rownames(host_dist))) %>%
    mutate(total=rowSums(select_if(., is.numeric))) %>%
    filter(total > 0) %>%
    dplyr::select(-total) %>%
    column_to_rownames("SampleID") %>%
  as.matrix

# convert to binary
otu <- otu %>% apply(2, function(x) ifelse(x > 0, 1, 0)) %>% as.matrix
                    

# 1 - host phylogenetic distance matrix
phylo.dist


#Cophenetic distance
#psyllid_tree <- read.tree(text=readLines("sample_data/psyllid_beast_tree.nwk"))

# Match names with alpha diversity
#psyllid_tree$tip.label <- psyllid_tree$tip.label %>%
#  str_replace_all(pattern="\\.", replacement=" ") %>%
#  str_replace_all(pattern="sp$", replacement="sp. ") %>%
#  str_replace_all(pattern="Acizzia hakae", replacement="Acizzia hakeae") %>%
#  str_replace_all(pattern="POLLENISLAND", replacement="POLLEN ISLAND") %>%
#  str_replace_all(pattern="Ctenarytaina fuchsiae$", replacement="Ctenarytaina fuchsia A") %>%
#  str_replace_all(pattern="Ctenarytaina fuchsiaeB", replacement="Ctenarytaina fuchsia B") %>%
#  str_replace_all(pattern="Ctenarytaina fuchsiaeC", replacement="Ctenarytaina fuchsia C") %>%
#  str_replace_all(pattern="Ctenarytaina clavata", replacement="Ctenarytaina clavata sp. ") %>%
#  str_replace_all(pattern="Ctenarytaina clavata sp. $", replacement="Ctenarytaina clavata sp. A") %>%
#  str_replace_all(pattern="Ctenarytaina sp$", replacement="Ctenarytaina sp. ") %>%
#  str_replace_all(pattern="Ctenarytaina unknown", replacement="Ctenarytaina insularis") %>%  
#  str_replace_all(pattern="Psylla apicalis A", replacement="Psylla frodobagginsi") %>%
#  str_replace_all(pattern="Psylla apicalis B", replacement="Psylla apicalis") %>%
#  str_replace_all(pattern="carmichaeliae", replacement="carmichaeliae ") %>%
#  str_replace_all(pattern="Psylla apicalis", replacement="Psylla apicalis ") %>% # Should these be A,B or?
#  str_replace_all(pattern="Trioza sp", replacement="Trioza sp. ") %>%
#  str_replace_all(pattern="Trioza acutaB", replacement="Trioza Acuta B") %>%
#  str_replace_all(pattern="BRENDAMAY", replacement="BRENDA MAY") %>%
#  str_replace_all(pattern="PRICES", replacement="PRICE'S VALLEY") %>%
#  trimws(which="right")
#
#
#psyllid_tree$tip.label[!psyllid_tree$tip.label %in% bt_randomdf$psyllid_spp]
#
#pruned.tree <- drop.tip(psyllid_tree, psyllid_tree$tip.label[!psyllid_tree$tip.label %in% bt_randomdf$psyllid_spp] )
#psyllid_tree$tip.label[!psyllid_tree$tip.label %in%  pruned.tree$tip.label]
#
#cophenetic <- cophenetic(pruned.tree)

# 2 - Microbe distance matrix (cophenetic?)
micro_phylo <- cophenetic(phy_tree(ps2.glom))



# Compare distributions

phylo.dist %>% as.vector %>% summary %>% print
micro_phylo %>% as.vector %>% summary %>% print
                    

host_dist <- phylo.dist %>% as.matrix

setdiff(rownames(host_dist), rownames(otu))
setdiff(rownames(otu), rownames(host_dist))

otu
# prepare paco data
D = prepare_paco_data(H=phylo.dist %>% as.matrix, P=micro_phylo, HP=otu)
D %>% names

# Add pcord

D = add_pcoord(D, correction='cailliez')
D %>% names

D$H_PCo %>% as.vector %>% summary %>% print
D$P_PCo %>% as.vector %>% summary %>% print

# plot Principal coordinates
neg_to_pos_eig = function(PCo){
    min_val = PCo %>% as.vector %>% min
    print(min_val)
    if(min_val < 0){
        PCo = PCo + abs(min_val)
    }
    return(PCo)
}

D$H_PCo = neg_to_pos_eig(D$H_PCo)
D$P_PCo = neg_to_pos_eig(D$P_PCo)

# status
D$H_PCo %>% as.vector %>% summary %>% print
D$P_PCo %>% as.vector %>% summary %>% print

tmp = D$H_PCo[,c('Axis.1', 'Axis.2')] %>% as.data.frame
p_host = ggplot(tmp, aes(Axis.1, Axis.2)) +
    geom_point() +
    theme_bw()

tmp = D$P_PCo[,c('Axis.1', 'Axis.2')] %>% as.data.frame
p_micro = ggplot(tmp, aes(Axis.1, Axis.2))  +
    geom_point() +
    theme_bw()
    
plot(p_micro)
plot(p_host)

# run paco
paco_shortrun <- PACo(D, nperm=99, seed=39473, method='quasiswap', symmetric=TRUE)

paco_residuals <- residuals_paco(paco_shortrun$proc, type = "interaction")

paco_l <- paco_links(paco_shortrun)

paco_run <- PACo(D, nperm=999, seed=39473, method='r0', symmetric=FALSE)

# Visualise residuals
res <- data.frame(res=paco_residuals) %>%
  rownames_to_column("OTU") %>%
  separate(OTU, into=c("SampleID", "OTU")) %>%
  left_join(as.data.frame(tax_table(ps2)) %>%
              rownames_to_column("OTU"), by="OTU")
ggplot(res, aes(x=res))+
  geom_density(fill='grey70')+
  facet_wrap(~Phylum) +
  theme_bw()+
  xlab('Procrustes residuals')+
  ylab('Frequency')

# Cophyloplot requires 2 phylo objects, and a matrix with 2 columns specifying the associations between the tips

assoc <- data.frame(pol=rownames(otu)[which(int==otu, arr.ind=TRUE)[,'row']], pla=colnames(int)[which(int==1, arr.ind=TRUE)[,'col']])
# to weight the interactions we use the cophylogenetic contribution transformed to best show
# the differences graphically
weight <- (res^-2)/50

cophyloplot(poll_phy, pla_phy, otu, show.tip.label=FALSE, use.edge.length=FALSE,
	lwd=weight, col='steelblue', length.line=0, gap=-20, space=60)


# Welch's t-test to test the difference between cophylogenetic signal of interactions
ttest <- t.test(cophy, noncophy)

# visualise the difference with a box and whisker plot
dat <- rbind(data.frame(cophy=cophy, level='high'), data.frame(cophy=noncophy, level='rest'))
ggplot(dat, aes(x=level, y=cophy, fill=level))+
geom_boxplot(alpha=0.85)+
scale_fill_brewer(palette='Paired')+
scale_x_discrete(labels=c('L-M/O','Rest'))+
ylab('Procrustes residual')+
theme_bw()+
theme(
	axis.title.x=element_blank(),
	panel.grid=element_blank(),
	legend.position='none',
	axis.text.x=element_text(size=14),
	axis.title.y=element_text(size=14)
	)

# test the influence of degree on cophylogenetic signal
special <- data.frame(cophy.sig=res, pla_deg=NA, row.names=names(res))
f <- function(x) length(grep(strsplit(x, '-')[[1]][2], names(res)))
special$pla_deg <- sapply(rownames(special), f)

plant_degree <- summary(lm(cophy.sig ~ pla_deg, data=special))


# See how the global fit of the procrustes analysis changes over
# NExt - subset to each family and Conduct procrustes
# Next subset to the highest genus and try procrustes? 
# alternatively, could split tree at different phylogenetic levels and do it? Family is probably more sensible
```


```{r}


for (i in 1:length(glomseq)){
  
#ps.glom <- tip_glom(ps2, h=glomseq[i])
ps.glom <- phy_glom(ps2, similarity=glomseq[i])

treelist[[i]] <- ps.glom

#Rename taxa
taxa_names(ps.glom) <- paste0("SV", seq(ntaxa(ps.glom)),"-",tax_table(ps.glom)[,6])

ps2.n0 <- transform_sample_counts(ps.glom, function(x) x+1)

phy_tree(ps2.n0) <- multi2di(phy_tree(ps2.n0))
phy_tree(ps2.n0) <- makeNodeLabel(phy_tree(ps2.n0), method="number", prefix='n')

# philr dist
otu.table <- otu_table(ps2.n0)
tree <- phy_tree(ps2.n0)
metadata <- as(sample_data(ps2.n0), "data.frame")
tax <- tax_table(ps2.n0)
ps2.philr <- philr(otu.table, tree,
                  part.weights='enorm.x.gm.counts',
                  ilr.weights='blw.sqrt')
ps2.philr <- dist(ps2.philr, method="euclidean")

# CLR dist
ps2.clr <- t(abundances(ps2.n0))
ps2.clr <- codaSeq.clr(ps2.clr)
ps2.clr <- dist(ps2.clr, method="euclidean")

# Bray dist
ps2.bray <- vegdist(otu_table(ps.glom),method="bray")
#Jacard
ps2.jac <- vegdist(otu_table(ps.glom),method="jac",binary = T)

  for (d in 1:length(distances)){
  
  coda.dist <- get(distances[d])
  #coda.dist <- dist(dist_obj, method="euclidean")
  
  
  # ADONIS TESTS
  metadata <- as(sample_data(ps2.n0), "data.frame")
  
  
  ad_psyllid <- adonis(coda.dist ~ psyllid_spp, method = "euclidean",
                     data = metadata)$aov.tab %>%
    as_tibble(rownames="terms") %>%
    mutate(call = "psyllid_spp")
  
  
  ad_hostplant <- adonis(coda.dist ~ hostplant_spp, method = "euclidean",
                       data = metadata)$aov.tab %>%
    as_tibble(rownames="terms") %>%
    mutate(call = "hostplant_spp")
  
  #Interactions
  ad_psyllid_hostplant <- adonis(coda.dist ~ psyllid_spp*hostplant_spp, method = "euclidean",
                          data = metadata)$aov.tab %>%
    as_tibble(rownames="terms") %>%
    mutate(call = "psyllid_spp*hostplant_spp")
  
  ad_hostplant_psyllid <- adonis(coda.dist ~ hostplant_spp*psyllid_spp,
                          data = metadata)$aov.tab %>%
    as_tibble(rownames="terms") %>%
    mutate(call = "hostplant_spp*psyllid_spp")
  
  
  adlist[[d]] <- bind_rows(ad_psyllid, ad_hostplant, ad_psyllid_hostplant, ad_hostplant_psyllid) %>%
    mutate(distance = distances[d])
  
  
  ## Matrix correlations
  

adonis_stats <- bind_rows(adlist_distances)

gg.adonis <- ggplot(adonis_stats, aes(x=glom, y=R2, fill=call))

matrix_stats <- bind_rows(mantlist_distances) %>%
  mutate(signif_test = case_when(
    signif < 0.01 ~ TRUE,
    signif > 0.01 ~ FALSE
  ))


mantel <- matrix_stats %>% 
  filter(test %in% c("Mantel", "Partial Mantel")) %>%
  mutate(call = factor(call, levels = c(
    "M Microbe~Phylo", "PM Microbe~Phylo~Plant", "PM Microbe~Phylo~Geography", 
    "M Microbe~Geography", "PM Microbe~Geography~Phylo", "PM Microbe~Geography~Plant",
    "M Microbe~Plant", "PM Microbe~Plant~Phylo", "PM Microbe~Plant~Geography"
     )))

gg.mantel <- ggplot(mantel, aes(x=call, y=stat, fill=call)) + 
  geom_bar(stat="identity") + 
  geom_point(data=mantel %>% filter(signif_test==TRUE), aes(x = call, y=stat + 0.005), shape=8, colour="black") +
  scale_fill_brewer(palette="Spectral") + 
  facet_grid(distance~glom) +
  ylab("Mantel test statistic") +
  theme_classic() + 
  theme(axis.text.x = element_blank(),
        axis.ticks.x = element_blank(),
        legend.position = "bottom",
  panel.grid.major.y = element_line(colour="grey92", size=0.5, linetype="dashed"))

gg.manteline  <- ggplot(mantel, aes(x=glom, y=stat, colour=call)) + 
  geom_line(stat="identity") + 
  facet_wrap(~distance, ncol=1) +
  ylab("Mantel test statistic") +
  theme_classic() + 
  theme(panel.grid.major.y = element_line(colour="grey92", size=0.5, linetype="dashed"))

```


This suggests that species significantly cluster, and so do hostplants. However when accounting for species, hostplants are not significant. Therefore it should be justified to redo the barchart merging by species 



## Map of colleciton locations

```{r Collection map}
#Make spatial distance matrix
library(sp)
 # Spatial distance
  envData <- read.csv("sample_data/Sample_info.csv", header=TRUE)  %>%
    dplyr::filter(!duplicated(SampleID)) %>%
    set_rownames(.$SampleID) %>%
    separate(Collection, into= c("Lat", "Long"), sep=" ", remove = FALSE) %>%
    separate(Lat, paste("lat",c("d","m","s"), sep="_") ) %>%
    separate(Long, paste("long",c("d","m","s"), sep="_" ) ) %>%
    mutate_at(vars(-SampleID, -psyllid_spp), funs(as.numeric)) %>%
    mutate(lat=-(lat_d + lat_m/60 + lat_s/60^2),
              long=long_d + long_m/60 + long_s/60^2) %>%
    dplyr::select(SampleID, psyllid_spp, lat, long) %>%
    column_to_rownames("SampleID") %>%
    drop_na()

#Plot on map to confirm points
library("maptools")
data(wrld_simpl)
wrld_simpl@data$id <- wrld_simpl@data$NAME
wrld <- fortify(wrld_simpl, region="id")

gg.worldmap <- ggplot(envData) +
  geom_map(data=wrld, map=wrld, aes(map_id=id, x=long, y=lat), fill="lightgrey", color="#7f7f7f", size=0.25) +
  geom_point(aes(x=long, y=lat, color=psyllid_spp), alpha=.5, size=3) + 
  theme_bw() +
  coord_fixed(ylim = c(-90,90), xlim=c(-180,180))  

gg.anzmap <- ggplot(envData) +
  geom_map(data=wrld, map=wrld, aes(map_id=id, x=long, y=lat), fill="lightgrey", color="#7f7f7f", size=0.25) +
  geom_point(aes(x=long, y=lat, color=psyllid_spp), alpha=.5, size=3) + 
  theme_bw() +
  coord_fixed(ylim = c(-50,-30), xlim=c(130,180))+
  theme(legend.position = "bottom")  


gg.nzmap <- ggplot(envData) +
  geom_map(data=wrld, map=wrld, aes(map_id=id, x=long, y=lat), fill="lightgrey", color="#7f7f7f", size=0.25) +
  geom_point(aes(x=long, y=lat, color=psyllid_spp), alpha=.5, size=3) + 
  theme_bw() +
  coord_fixed(ylim = c(-50,-30), xlim=c(160,180)) 

```




## Primary symbiont


## Minimum abundance threshold

Maybe this should be done just for carsonella tree

These samples were sequenced using combinatorial indexes. Therefore this data will contain index switching. We therefore need to select an optimal filtering threshold to remove switched taxa, but not real taxa. We will optimise our filtering threshold by relying on assumption that all psyllid species should contain only one (or few very closely related ASVs) of Carsonella.

```{r thresholds}
#Flag top abundance carsonella
top_carson <-  ps2 %>%
  transform_sample_counts(function (x) x/sum(x)) %>%
  speedyseq::psmelt() %>%
  filter(Genus=="Candidatus_Carsonella") %>%
  group_by(Sample) %>%
  top_n(1, wt=Abundance) %>%
  mutate(top = TRUE)  %>%
  filter(Abundance > 0)
  
#Flag lower abundance carsonella
carson <-  ps2 %>%
  transform_sample_counts(function (x) x/sum(x)) %>%
  speedyseq::psmelt() %>%
  filter(Genus=="Candidatus_Carsonella") %>%
  left_join(top_carson) %>%
  mutate(top = case_when(
    is.na(top) ~ FALSE,
    !is.na(top) ~ top
  ))

## THis needs to be changed - things should be flagged as switched when less than 100* the top!, or combine both - ie 

carson <- carson %>%
  left_join(carson %>%
    filter(Abundance > 0) %>%
    dplyr::select(OTU, top, seqrun) %>%
    unique() %>%
    group_by(OTU, seqrun) %>%
    add_tally() %>%
    mutate(switched = case_when(
      n>1 & top== FALSE ~ TRUE,
      n>1 & top== TRUE ~ FALSE,
      n==1 ~ FALSE,
    )) %>%
  dplyr::select(-n)
  )

## Plot true and false carsonellas by run - this shows may need to filter seperately by run, as seqrun2 has much higher than others.
gg.switch <- carson %>% 
  group_by(seqrun, switched) %>%
  filter(!is.na(switched)) %>%
  filter(Abundance > 0) %>%
  summarise(n = n()) %>%
  mutate(freq = n / sum(n)) %>%
  ggplot(aes(x=seqrun, y=freq, group=switched, fill=switched)) +
  geom_bar(stat="identity")


#to check if index switching could explain the multiple OTU's check if top=FALSE carsonella exist as top in another sample in the same run

thresholds <- seq(0,0.05,0.0001)
out <- vector("list", length=3)
for (r in 1:3) {
  df <- data.frame(thresh = thresholds, TP= thresholds, FP = thresholds, seqrun = r)
  for(i in 1:length(thresholds)){
    filt <- carson %>%
      filter(seqrun==r) %>%
      filter(Abundance > thresholds[i]) %>%
      group_by(top) %>%
      summarise(sum=n())
    df$FP[i] <- filt$sum[1]
    df$TP[i] <- filt$sum[2]
  }
  out[[r]] <- df
}

gg.filt <- out %>%
  bind_rows() %>%
  gather(key=type, value=n, -thresh, -seqrun) %>%
  ggplot(aes(x=thresh, y=n, fill=type)) + 
  geom_density(stat="identity", alpha=0.5) + 
  scale_x_continuous(breaks=seq(0,0.05,0.001)) +
  facet_grid(~seqrun) +
  theme(axis.text.x = element_text(angle=45,hjust=1)) + 
  geom_vline(xintercept = 0.0035)+ 
  geom_vline(xintercept = 0.001)

print(gg.filt)

## Filter run 2 
run2_ps <- ps2 %>% 
  subset_samples(seqrun==2)

run2_pass <- run2_ps %>%
    transform_sample_counts(function (x) x/sum(x)) %>%  # Convert to proportions
    transform_sample_counts(function (x) (x > 0.001) * 1)

newotu1 <- otu_table(run2_ps) * otu_table(run2_pass)

run2_newps <- run2_ps
otu_table(run2_newps) <- otu_table(newotu1, taxa_are_rows = FALSE) 

#Filter run 1 and 3 
  
run13_ps <- ps2 %>%
    subset_samples(!seqrun == 2)
                   
run13_pass <- run13_ps %>%
    transform_sample_counts(function (x) x/sum(x)) %>%  # Convert to proportions
    transform_sample_counts(function (x) (x > 0.0005) * 1)

newotu2  <- otu_table(run13_ps) * otu_table(run13_pass)

run13_newps <- run13_ps
otu_table(run13_newps) <- otu_table(newotu2, taxa_are_rows = FALSE) 

# Create new phyloseq and drop missing taxa
ps3 <- merge_phyloseq(run2_newps, run13_newps) %>%
  filter_taxa(function(x) mean(x) > 0, TRUE) #Drop missing taxa from table
ps3 <- prune_samples(sample_sums(ps3) >0 , ps3) # Drop empty samples

#Count number of overall taxa pre and post filtering
print(paste(ntaxa(ps2) - ntaxa(ps3), " taxa Dropped when using filtering threshold of: ", 0.0035, " for run 2 and ", 0.001, "for run 1 and 3"))

# Count number of carsonella OTU's per sample pre and post filtering
n_carson <- speedyseq::psmelt(ps2) %>% 
  filter(Genus == "Candidatus_Carsonella") %>%
  filter(Abundance > 0) %>%
  dplyr::select(Sample.Name, OTU) %>%
  group_by(Sample.Name) %>%
  add_tally() %>%
  dplyr::select(-OTU) %>%
  unique() %>%
  mutate(type = "pre") %>%
  bind_rows(.,speedyseq::psmelt(ps3) %>% 
  filter(Genus == "Candidatus_Carsonella") %>%
  filter(Abundance > 0) %>%
  dplyr::select(Sample.Name, OTU) %>%
  group_by(Sample.Name) %>%
  add_tally() %>%
  dplyr::select(-OTU) %>%
  unique() %>%
  mutate(type = "post"))

gg.ncarson <- ggplot(n_carson, aes(x=reorder(Sample.Name, -n), y=n)) + 
  geom_bar(stat="identity") +
  facet_grid(~type) + 
  xlab("Sample.Name") +
  ylab("Number of carsonella OTU's per sample") +
  theme(axis.text.x = element_text(angle=90, hjust = 1, vjust=0))

print(gg.ncarson)

#check if any samples dont have carsonella
table(!n_carson$Sample.Name %in% speedyseq::psmelt(ps2)$Sample.Name)

## Get the name of taxa that dont have carsonella after filtering

```

```{r subsetting}
library(plotly)

#filter threshold to ge
#ps2.carson <- transform_sample_counts(ps2, fun = proportions, thresh=0.0045)

#ps2.carson <- subset_taxa(ps2.carson, Genus == "Candidatus_Carsonella")
#ps2.carson <- filter_taxa(ps2.carson, function(x) mean(x) > 0, TRUE) #Drop missing taxa from table
#ps2.carson <- prune_samples(sample_sums(ps2.carson)>0, ps2.carson) # Drop empty samples

library(RColorBrewer)
col <- colorRampPalette(brewer.pal(11, "Spectral"))(74)


ps2.carson <- subset_taxa(ps2, Species == "Candidatus Carsonella")
gg.carson <- plot_tree(ps2.carson, ladderize="left",  color="psyllid_spp") +   theme(legend.position = "none") + #
    scale_colour_manual(values=col) + scale_fill_manual(values=col)
  ggtitle("Carsonella 16S gene tree")
#gg.ncarson
  
## Aquabacterium
gg.tree <- plot_tree(subset_taxa(ps2, Species == "Sulfuritalea"), ladderize="left",  color="psyllid_spp") +   theme(legend.position = "none") + #
    scale_colour_manual(values=col) + scale_fill_manual(values=col)
  ggtitle("Carsonella 16S gene tree")
#gg.ncarson

#Write out fasta

carson_out <- speedyseq::psmelt(ps3.carson) %>%
  filter(Abundance > 0) %>%
  select(OTU, Sample.Name, psyllid_spp, Species) %>%
  group_by(OTU, Species) %>%
  summarize(samples = paste(Sample.Name, collapse=";"),
            psyllid_spp = paste(unique(psyllid_spp), collapse=";")
            ) %>%
  rownames_to_column() %>%
  unite(seqname, c("Species","rowname","psyllid_spp","samples"), sep="|")

carson_fasta <- DNAStringSet(carson_out$OTU)
names(carson_fasta) <- carson_out$seqname

writeXStringSet(carson_fasta, "carsonella_seqs.fa")


## S-Symbionts
ps3.carson <- subset_taxa(ps3, Family == "Enterobacteriaceae")
taxa_names(ps3.carson) <- paste0("SV", seq(ntaxa(ps3.carson)),"-",tax_table(ps3.carson)[,7])

gg.entero <- plot_tree(ps3.carson, ladderize="left",  color="psyllid_spp", label.tips="taxa_names") +   theme(legend.position = "none") +     #scale_colour_manual(values=col) +
  ggtitle("Enterobacidae 16S gene tree")

#, label.tips="psyllid_spp

```




```{r session-info}
# Display current R session information
sessionInfo()
```
