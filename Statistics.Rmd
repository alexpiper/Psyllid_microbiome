---
title: "Psyllid microbiome Statistics"
author: "Alexander Piper"
date: "14/08/2019"
output: html_document
editor_options: 
  chunk_output_type: console
---

## Load packages 

```{r install & Load packages} 
#Set required packages
.cran_packages <- c("tidyverse", "patchwork", "vegan", "seqinr", "viridis", "ape", "sp", "data.table", "RColorBrewer", "ggtree", "castor", "abind", "Matrix", "minpack.lm", "Hmisc", "data.tree", "entropy", "picante", "MCMCglmm", "phylosignal", "adephylo")
.bioc_packages <- c("dada2", "phyloseq", "DECIPHER","Biostrings","ShortRead", "microbiome","philr", "ALDEx2")

.inst <- .cran_packages %in% installed.packages()
if(any(!.inst)) {
   install.packages(.cran_packages[!.inst])
}
.inst <- .bioc_packages %in% installed.packages()
if(any(!.inst)) {
  if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")
  BiocManager::install(.bioc_packages[!.inst], ask = F)
}

sapply(c(.cran_packages,.bioc_packages), require, character.only = TRUE)

# Github packages
devtools::install_github("alexpiper/taxreturn")
library(taxreturn)
devtools::install_github("alexpiper/seqateurs")
library(seqateurs)
devtools::install_github("mikemc/speedyseq")
library(speedyseq)
devtools::install_github('ggloor/CoDaSeq/CoDaSeq')
library(CoDaSeq)
devtools::install_github("DanielSprockett/reltools")
library(reltools)

#Source internal functions
source('R/helper_functions.R')
source('R/BDTT.R')
options(stringsAsFactors = FALSE)
```

## Make Phyloseq object

Following taxonomic assignment, the sequence table and taxonomic table are merged into a single phyloseq object alongside the sample info csv.

We then make a plot to evaluate the effectiveness of taxonomic assignment to each rank

```{r create PS, eval = FALSE}
seqtab_final <- readRDS("output/rds/seqtab_final.rds")
tax <- readRDS("output/rds/tax_IdTaxaExact.rds") 
fitGTR <- readRDS("output/rds/phytree.rds") 

#Load sample information (Put all collection and geographic distances here?)
## ---- samdat ----
samdf <- read_csv("sample_data/Sample_info.csv")  %>%
  dplyr::filter(!duplicated(SampleID)) %>%
  dplyr::rename_all(funs( stringr::str_replace_all(., '\\ ', '_')) )

# Flag replicated samples
samdf <- samdf %>%
  dplyr::mutate(replicated = Sample_Name %in% (samdf %>% group_by(Sample_Name) %>% 
                                                 add_count() %>%
                                           filter(n >1) %>% 
                                           pull(Sample_Name))) %>%
  separate(Collection, into= c("Lat", "Long"), sep=" ", remove = TRUE) %>%
  separate(Lat, paste("lat",c("d","m","s"), sep="_")) %>%
  separate(Long, paste("long",c("d","m","s"), sep="_" )) %>%
  mutate_at(vars(starts_with("lat")), .funs=as.numeric) %>%
  mutate_at(vars(starts_with("long")), .funs=as.numeric) %>%
  mutate(lat=-(lat_d + lat_m/60 + lat_s/60^2),
            long=long_d + long_m/60 + long_s/60^2) %>%
  dplyr::select(c("SampleID", "Sample_Name", "seqrun", "psyllid_spp", "psyllid_genus", "psyllid_family", "hostplant_spp","Collection_Date","replicated", "lat", "long")) %>%
  as.data.frame(stringsAsFactors=FALSE) %>%
  magrittr::set_rownames(.$SampleID) #Collection

## ---- phyloseq ----
ps <- phyloseq(tax_table(tax), sample_data(samdf),
               otu_table(seqtab_final, taxa_are_rows = FALSE),
               phy_tree(fitGTR$tree))

if(nrow(seqtab_final) > nrow(sample_data(ps))){warning("Warning: All samples not included in phyloseq object, check sample names match the sample metadata")}

##save phyloseq object
saveRDS(ps, "output/rds/ps.rds")

#Output tables of results
dir.create("output/csv")
dir.create("output/csv/unfiltered/")

##Export raw csv
speedyseq::psmelt(ps) %>%
  write.csv(file = "output/csv/rawdata.csv")

seqateurs::summarise_taxa(ps, "species", "SampleID") %>%
  spread(key="SampleID", value="totalRA") %>%
  write.csv(file = "output/csv/unfiltered/spp_sum.csv")

seqateurs::summarise_taxa(ps, "genus", "SampleID") %>%
  spread(key="SampleID", value="totalRA") %>%
  write.csv(file = "output/csv/unfiltered/gen_sum.csv")
```

### Summarise taxonomic assignment

```{r sum taxa}
#Fraction of reads assigned to each taxonomic rank
sum_reads <- speedyseq::psmelt(ps) %>%
  gather("Rank","Name",rank_names(ps)) %>%
  group_by(Rank) %>% 
  mutate(Name = replace(Name, str_detect(Name, "__"),NA)) %>% # This line turns the "__" we added to lower ranks back to NA's
  dplyr::summarise(Reads_classified = sum(Abundance * !is.na(Name))) %>%
  mutate(Frac_reads = Reads_classified / sum(sample_sums(ps))) %>%
  mutate(Rank = factor(Rank, rank_names(ps))) %>%
  arrange(Rank)

#Fraction of ASV's assigned to each taxonomic rank
sum_otu <- tax_table(ps) %>%
  as("matrix") %>%
  as_tibble(rownames="OTU") %>%
  gather("Rank","Name",rank_names(ps)) %>%
  group_by(Rank) %>%
  mutate(Name = replace(Name, str_detect(Name, "__"),NA)) %>% # This line turns the "__" we added to lower ranks back to NA's
  dplyr::summarise(OTUs_classified = sum(!is.na(Name))) %>%
  mutate(Frac_OTUs = OTUs_classified / ntaxa(ps)) %>%
  mutate(Rank = factor(Rank, rank_names(ps))) %>%
  arrange(Rank)

print(sum_reads)
print(sum_otu)
```


# Curate with LULU

Need to fix ps_to_fasta - Allow writing of asv sequences as names

Need to allow blast to take in

```{r LULU}
library(lulu)
# Make blast database from the ASV's
seqateurs::ps_to_fasta(ps, "output/all_taxa.fasta", seqnames = "sequence")
taxreturn::blast_install(dest.dir = "bin")

# Blast against themseleves
seqs <- insect::char2dna(colnames(seqtab_final))
names(seqs) <- colnames(seqtab_final)
matchlist <- blast(query=seqs, db="output/all_taxa.fasta", output_format = "tabular") %>%
  select(qseqid, sseqid, pident) %>%
  as.data.frame()

# Run lulu
otutab <- as.data.frame(t(seqtab_final))
curated_result <- lulu(otutab, matchlist)
saveRDS(curated_result, "lulu_curated.rds")

# get mapping
curated_result <- readRDS("lulu_curated.rds")
mapping <- curated_result[["otu_map"]] %>% 
  rownames_to_column("otu") %>%
  left_join(tax %>% as.data.frame %>% rownames_to_column("otu"), by="otu")

#assign_to ps
ps_curated <- ps
otu_table(ps_curated) <- otu_table(t(curated_result$curated_table), taxa_are_rows = FALSE)
ps_curated <- ps_curated %>% #Remove mocks
  filter_taxa(function(x) mean(x) > 0, TRUE) #Drop missing taxa from table 
message(ntaxa(ps) - ntaxa(ps_curated), " removed by LULU curation")

```


Look at the taxa in the mocks + pcr controls. COuld i use these with decontam?

## Detect and remove outlier Samples

Detecting and potentially removing samples outliers (those samples with underlying data that do not conform to experimental or biological expectations) can be useful for minimizing technical variance. This can be caused by a number of reasons, including low-reads assigned to that sample. In this case we remove all samples below 1000 reads, as these include all samples contributing to lower than usual ASV counts.

Rarefaction curves are useful	to	assess	sensitivity	of	sample	size	to	observed	alpha-diversity estimates.
```{r replicate reproducibility}
## Remove mocks
rm_mocks <- c("mockA_S51", "MockEven_S193", "Mock_S192", "PCRctrl_S191", "MockStaggered_S194", "PCRctrl_S191", "91_S167")

#check mocks
#ps0 <- ps_curated %>% 
ps0 <- ps %>% 
  subset_samples(!sample_names(ps) %in% rm_mocks) %>% #Remove mocks
  filter_taxa(function(x) mean(x) > 0, TRUE) #Drop missing taxa from table 

message((nsamples(ps) - nsamples(ps0)), " outlier samples dropped")

#Plot rarefaction curve
out <- rarecurve(otu_table(ps0), step=100)

rare <- lapply(out, function(x){
  b <- as.data.frame(x)
  b <- data.frame(OTU = b[,1], count = rownames(b))
  b$count <- as.numeric(gsub("N", "",  b$count))
  return(b)
})
names(rare) <- sample_names(ps1)

rare <- map_dfr(rare, function(x){
  z <- data.frame(x)
  return(z)
}, .id = "sample")

# threshold for read removal
threshold = 1000

gg.rare <- ggplot(data = rare)+
  geom_line(aes(x = count, y = OTU, group=sample), alpha=0.5)+
  geom_point(data = rare %>% group_by(sample) %>% top_n(1, count),aes(x = count, y = OTU, colour=(count > threshold))) +
  scale_x_continuous(labels =  scales::scientific_format()) +
  geom_vline(xintercept=threshold, linetype="dashed") +
  labs(colour = "> Read \n Threshold") +
  xlab("Sequence reads") +
  ylab("Observed ASV's")

gg.rare

#Remove all samples under the minimum read threshold 
ps1 <- prune_samples(sample_sums(ps0)>=threshold, ps0) 
ps1 <- filter_taxa(ps1, function(x) mean(x) > 0, TRUE) #Drop missing taxa from table
message(nsamples(ps) - nsamples(ps1), " Samples and ", ntaxa(ps) - ntaxa(ps1), " taxa under read threshold Dropped")
```

## Average dissimilarities

Calculate Average dissimilarities between PCR replicates, biological replicates of the same species, hostplants, and different species on same hostplants

```{r Avg Dissimiarity}
# Calculate overall distance
#Rarefy replicates to same read depth
nspec <- specnumber(otu_table(ps1)) # observed number of species
raremax <- min(rowSums(otu_table(ps1)))
rare <- rrarefy(otu_table(ps1), raremax)

dist <- vegan::vegdist(rare, method="bray") %>%
  as.matrix()

# Plot pca
r.pcx <- prcomp(dist)
factoextra::fviz_pca_biplot(r.pcx)

# Reformat to Long format
xy <- t(combn(colnames(dist), 2))
pw <- data.frame(xy, dist = dist[xy]) %>%
  set_colnames(c("SampleID.x", "SampleID.y", "dist")) %>%
  left_join(samdf %>% 
              dplyr::select(SampleID, Sample_Name, psyllid_spp, psyllid_genus, hostplant_spp, replicated) %>%
              dplyr::rename(SampleID.x = SampleID), by="SampleID.x")%>%
  left_join(samdf %>% 
              dplyr::select(SampleID, Sample_Name, psyllid_spp, psyllid_genus, hostplant_spp, replicated) %>%
              dplyr::rename(SampleID.y = SampleID), by="SampleID.y")


# Distance between replicates of same sample
repdist <- pw %>% filter(Sample_Name.x == Sample_Name.y)

# Distance between samples of same species
sppdist <- pw %>% filter(psyllid_spp.x == psyllid_spp.y)

# Distance between psyllids on same hostplat
#      psyllopsis fraxini 94- 107 - 113
# psyllopsis fraxinicola 93 - 106 - 112
# 93+94 were the same tree, 106+107 on the same tree and 112+113 were the same treee
hostplantdist <- pw %>% filter(psyllid_spp.x == psyllid_spp.y)

dist <- ps1 %>% 
    subset_samples(Sample_Name %in%  c("93", "94","106", "107","112", "113")) %>%
    filter_taxa(function(x) mean(x) > 0, TRUE) %>%
    otu_table()  %>%
    vegan::vegdist(method="jaccard")

factoextra::fviz_pca(prcomp(dist))

# Otther set
#psylla apicalis 200 - 201
#psylla frodobagginsi 200 - 201 #in this case they are named after their tree - ie 200 and 200 were same tree, i shoul drename thes ein some way

dist2 <- ps1 %>% 
    subset_samples(Sample_Name %in%  c("200", "94","106", "107","112", "113")) %>%
    filter_taxa(function(x) mean(x) > 0, TRUE) %>%
    otu_table()  %>%
    vegan::vegdist(method="jaccard")

# could i do some cluster analysis here?

# Or is adonis besst
#adonis(~ psyllid_spp, method = "euclidean", data = metadata))
```

### Merge technical replicates

With only 16 samples replicated, and only on the first 2 sequencing runs i dont think there is a way to explicitly take into account replicate variability, therefore all replicates were merged

```{r replicates}
# Merge replicates
ps.merged <- ps1 %>%
    merge_samples(group = "Sample_Name")

#This loses the sample metadata - Need to add it agian
sample_data(ps.merged) <- sample_data(ps1) %>%
  filter(!duplicated(Sample_Name)) %>%
  magrittr::set_rownames(.$Sample_Name)

#Drop missing taxa from table
ps.merged <- filter_taxa(ps.merged, function(x) mean(x) > 0, TRUE)
```

## Prevalence assesment

View prevalence of different phyla
```{r prevalence-assessment}
# Calculate taxon prevalence across the data set
prevdf <- apply(X = otu_table(ps.merged), MARGIN = ifelse(taxa_are_rows(ps.merged), yes = 1, no = 2), FUN = function(x){sum(x > 0)})

# Add taxonomy and total read counts to prevdf - change this to tidyverse code
prevdf <- data.frame(Prevalence = prevdf, TotalAbundance = taxa_sums(ps.merged), tax_table(ps.merged))

#Prevalence plot
gg.prev <- subset(prevdf, phylum %in% get_taxa_unique(ps0, "phylum")) %>%
  ggplot(aes(TotalAbundance, Prevalence / nsamples(ps.merged),color=family)) +
  geom_point(size = 3, alpha = 0.7) +
  scale_x_log10() +
  xlab("Total Abundance") + ylab("Prevalence [Frac. Samples]") +
  facet_wrap(~phylum) +
  theme(legend.position="none") +
  ggtitle("Phylum Prevalence in All Samples\nColored by Family")

gg.prev
```

## Taxon Filtering

Remove all non-bacterial taxa, mitochondria, chloroplast and cyanobacteria.
We also remove all taxa contained within the blank sample from other samples? - Check these

```{r taxon-cleaning}
get_taxa_unique(ps.merged, "domain")

ps.merged # Check the number of taxa prior to removal
ps2 <- ps.merged %>%
  subset_taxa(
    domain == "Bacteria" & #This is probably the only required one
    family  != "Mitochondria" &
    order   != "Chloroplast" &
    phylum != "Cyanobacteria"
  )
ps2 # Confirm that the taxa were removed
get_taxa_unique(ps2, "phylum")
get_taxa_unique(ps2, "class")
get_taxa_unique(ps2, "family")
```

# Community Diversity

## Summary of most common taxonomic groups

## Alpha diversity & Phylogenetic diversity

alpha diversity (observed, phylogenetic,  alpha-diversity metrics like Shannon/SImpson etc)

In order to further test this notion and to assess how environmental filtering may differ among host clades, we utilized two ecophylogenetics analyses: mean phylogenetic distance (MPD) and mean nearest taxon distance (MNTD). These tests assess the degree of phylogenetic clustering within each sample (host) relative to a permuted null model. Assuming phylogenetic niche conservatism (i.e., closely related taxa overlap along niche axes), then host diet or gut physiology may select for phylogenetically clustered taxa with overlapping niches, while in the absence of such strong selection, competition via niche conservatism would lead to phylogenetic overdispersion40. Phylogenetic overdispersion may also result from facilitation (i.e., beneficial microbeâ€“microbe interactions), such as when distantly related taxa form consortia to break down complex plant polymers40. MPD is more sensitive to overall patterns of phylogenetic clustering and evenness, while MNTD is more sensitive to patterns at the tree tips41.

Test this with rarefied samples to see the robustness to sequencing depth variation
```{r alpha diversity}
phy <- phyloseq::phy_tree(ps2)
phydist <- cophenetic(phy)
comm <- as(phyloseq::otu_table(ps2), "matrix") 

# Get richness measures
richness <- phyloseq::estimate_richness(ps2, measures=c("Chao1", "Shannon", "Simpson")) %>%
  rownames_to_column("Sample_Name") %>%
  mutate(Sample_Name = Sample_Name %>% 
           str_remove("^X") %>%
           str_replace_all("\\.", " "))

#Set number of randomisations for calculating significance
randoms <- 10

# Calculate Faith's PD-index & Species richness - with Standard errors
sespd <- picante::ses.pd(comm, phy, null.model = "taxa.labels", include.root = F, runs = randoms)

# Weighted mpd
w_mpd <- picante::ses.mpd(comm, phydist, null.model = "taxa.labels", abundance.weighted = TRUE, runs = randoms)

#Unweighted mpd
u_mpd <- picante::ses.mpd(comm, phydist, null.model = "taxa.labels", abundance.weighted = FALSE, runs = randoms) 

# Weighted mntd
w_mntd <- picante::ses.mntd(comm, phydist, null.model = "taxa.labels", abundance.weighted = TRUE, runs = randoms) 

# Unweighted NRI
u_mntd <- picante::ses.mntd(comm, phydist, null.model = "taxa.labels", abundance.weighted = FALSE, runs = randoms) 

# Join together
div_table <- sespd %>%
  rownames_to_column("Sample_Name") %>%
  select(Sample_Name, ntaxa, pd.obs.z) %>%
  bind_cols(w_mpd %>% select(contains("obs.z"))) %>%
  bind_cols(u_mpd %>% select(contains("obs.z"))) %>%
  bind_cols(w_mntd %>% select(contains("obs.z"))) %>%
  bind_cols(u_mntd %>% select(contains("obs.z"))) %>%
  dplyr::rename(alpha = ntaxa, pd = pd.obs.z,
         w_mpd = mpd.obs.z, u_mpd = mpd.obs.z1,
         w_mntd = mntd.obs.z, u_mntd = mntd.obs.z1)  %>%
  left_join(richness, by="Sample_Name") %>%
  left_join(sample_data(ps2) %>% 
              as.data.frame() %>%
              filter(!duplicated(Sample_Name)) %>%
              select(Sample_Name, psyllid_spp),
            by = "Sample_Name") 
# Summarise means
div_table %>%
  summarise_if(is.numeric, mean)

```


## Association with phylogeny 

Here we calculate the phylogenetic signal in the alpha diversity and community assembly metrics, or the extent to which these values are statistically related to phylogeny.

## Read in psyllid phylogeny
```{R psyllid phylogeny}
psyllid_tree <- read.tree(text=readLines("sample_data/psyllid_beast_tree.nwk"))

# Match names with alpha diversity
psyllid_tree$tip.label <- psyllid_tree$tip.label %>%
  str_replace_all(pattern="\\.", replacement=" ") %>%
  str_replace_all(pattern="sp$", replacement="sp. ") %>%
  str_replace_all(pattern="Acizzia hakae", replacement="Acizzia hakeae") %>%
  str_replace_all(pattern="POLLENISLAND", replacement="POLLEN ISLAND") %>%
  str_replace_all(pattern="Ctenarytaina fuchsiae$", replacement="Ctenarytaina fuchsia A") %>%
  str_replace_all(pattern="Ctenarytaina fuchsiaeB", replacement="Ctenarytaina fuchsia B") %>%
  str_replace_all(pattern="Ctenarytaina fuchsiaeC", replacement="Ctenarytaina fuchsia C") %>%
  str_replace_all(pattern="Ctenarytaina clavata", replacement="Ctenarytaina clavata sp. ") %>%
  str_replace_all(pattern="Ctenarytaina clavata sp. $", replacement="Ctenarytaina clavata sp. A") %>%
  str_replace_all(pattern="Ctenarytaina sp$", replacement="Ctenarytaina sp. ") %>%
  str_replace_all(pattern="Ctenarytaina unknown", replacement="Ctenarytaina insularis") %>%  
  str_replace_all(pattern="Psylla apicalis A", replacement="Psylla frodobagginsi") %>%
  str_replace_all(pattern="Psylla apicalis B", replacement="Psylla apicalis") %>%
  str_replace_all(pattern="carmichaeliae", replacement="carmichaeliae ") %>%
  str_replace_all(pattern="Psylla apicalis", replacement="Psylla apicalis ") %>% # Should these be A,B or?
  str_replace_all(pattern="Trioza sp", replacement="Trioza sp. ") %>%
  str_replace_all(pattern="Trioza acutaB", replacement="Trioza Acuta B") %>%
  str_replace_all(pattern="BRENDAMAY", replacement="BRENDA MAY") %>%
  str_replace_all(pattern="PRICES", replacement="PRICE'S VALLEY") %>%
  trimws(which="right")


# Subset to only those in sample data
psyllid_tree$tip.label[!psyllid_tree$tip.label %in% sample_data(ps2)$psyllid_spp]
pruned.tree <- drop.tip(psyllid_tree, psyllid_tree$tip.label[!psyllid_tree$tip.label %in% sample_data(ps2)$psyllid_spp] )

# CHeck which are missing
psyllid_tree$tip.label[!psyllid_tree$tip.label %in%  pruned.tree$tip.label]
```

## Calculate phylogenetic signal

```{r Phylosignal}
dat <- div_table  %>%
  filter(psyllid_spp %in% pruned.tree$tip.label) %>%
  group_by(psyllid_spp) %>%
  select(-Sample_Name) %>%
  summarise_all(mean) %>%
  arrange(match(psyllid_spp, pruned.tree$tip.label)) %>%
  as.data.frame() %>%
  magrittr::set_rownames(.$psyllid_spp) %>%
  select(-psyllid_spp)

# Add positive and negative controls
dat$random <- rnorm(length(dat$alpha), sd = 10) #Random association
dat$bm <- rTraitCont(pruned.tree) #Brownian motion

# Make phylosignal object and measure signal between univariate traits.
p4d <- phylobase::phylo4d(pruned.tree, dat)	
signal <- phylosignal::phyloSignal(p4d = p4d, method = "all")	

# Plots
barplot.phylo4d(p4d, tree.type = "phylo", tree.ladderize = TRUE)

correl <- vector("list", length=length(dat))
for (i in 1:length(dat)) {
  correl[[i]] <- phyloCorrelogram(p4d, trait = names(dat[i]))
  plot(correl[[i]], main= names(dat[i]))
}

# Locate signal
lipa <- lipaMoran(p4d)
lipa.p4d <- lipaMoran(p4d, as.p4d = TRUE)

barplot.phylo4d(p4d, bar.col=(lipa$p.value < 0.05) + 1, center = FALSE , scale = FALSE)

barplot.phylo4d(lipa.p4d, bar.col = (lipa$p.value < 0.05) + 1, center = FALSE, scale = FALSE)

# Asses modelbehavior	
phylosim <- phyloSim(tree = pruned.tree, method = "all", nsim = 100, reps = 99)	
plot.phylosim(phylosim, what = "pval", stacked.methods = TRUE)	
```	

## MCMCGLM
Would be better to integrate this with a phylogenetic glmm - see mcmc.OTU package or mcmcGLMM

Guide to calculating lambda using mcmcglmm - http://www.mpcm-evolution.com/practice/online-practical-material-chapter-11/chapter-11-1-simple-model-mcmcglmm


```{r mcmc glmm}
library(ape)
library(MCMCglmm)
phylo <- pruned.tree
data <- dat
head(data)

inv.phylo<-inverseA(pruned.tree, nodes="ALL")


prior<-list(G=list(G1=list(V=1,nu=0.02)),R=list(V=1,nu=0.02))
  
model_simple<-MCMCglmm(phen~cofactor, random=~phylo, 
  family="gaussian", ginverse=list(phylo=inv.phylo$Ainv) ,prior=prior,
  data=data, nitt=5000000, burnin=1000, thin=500)

summary(model_simple)
```


# Figure 1 

Merge species, arrange microbiome by phylogeny, try the mantel tests on the merged data as well (but the seperate is probs more statistically better)

RESULTS: while there were significant differences between psyllid species (see betta results), there were no significant associations with phylogeny
```{r Figure 1}

# Merge species for beta diversity
ps.sppmerged <- ps2 %>%
    merge_samples(group = "psyllid_spp", fun=mean)


#This loses the sample metadata - Need to add it agian
samdf <- read.csv("sample_data/Sample_info.csv", header=TRUE) %>%
  filter(!duplicated(psyllid_spp)) %>%
  set_rownames(.$psyllid_spp) %>%
  dplyr::select(c("SampleID", "Sample_Name", "seqrun", "psyllid_spp", "psyllid_genus", "psyllid_family", "hostplant_spp","Collection","Collection.Date"))

sample_data(ps.sppmerged) <- samdf
ps4 <- filter_taxa(ps.sppmerged, function(x) mean(x) > 0, TRUE) #Drop missing taxa from table

#Rename taxa
taxa_names(ps4) <- paste0("SV", seq(ntaxa(ps4)),"-",tax_table(ps4)[,6])

ps4_bar <- #subset_taxa(ps3, !Family == "Enterobacteriaceae") %>%
            ps4 %>%
  speedyseq::tax_glom(taxrank = "Order") %>%           # agglomerate at Order level
  transform_sample_counts(function(x) {x/sum(x)} ) %>% # Transform to rel. abundance
  speedyseq::psmelt() %>%
  mutate(plotlabel = Phylum) %>%
  mutate(plotlabel = case_when(
    Abundance >= 0.01 & Phylum=="Proteobacteria" ~ paste0(Phylum, " - ", Order), # Change this to whatever taxrank we want
    Abundance >= 0.01 & !Phylum=="Proteobacteria"~ Phylum ,
    Abundance < 0.01 ~ "NA"
    )) %>%
  dplyr::na_if("NA") %>%
  select(Sample, plotlabel, Phylum, Order, Abundance)

# Plot them together
library(ggtree)
library(treeio)
p <- ggtree(pruned.tree) + geom_tiplab(align=TRUE) + geom_nodelab(geom='label') +
    scale_x_continuous(expand=c(0, 0.1)) + theme_tree2()


Fig1 <- facet_plot(p, panel='Relative Abundance', data = ps4_bar %>% mutate(id = Sample), geom=ggstance::geom_barh,
                 mapping=aes(x = Abundance, fill = plotlabel), stat="identity")  + 
  scale_fill_manual(values=colorRampPalette(brewer.pal(11, "Set1"))(length(unique(ps4_bar$plotlabel))-1), na.value="grey")


Fig1 <- facet_plot(Fig1, panel='Species Richness', data = bt_randomdf %>% mutate(id = psyllid_spp),
                          geom=ggstance::geom_pointrangeh,
                           mapping=aes(x=Estimates, xmin=Estimates-SE, xmax=Estimates+SE),
                           stat="identity", size=0.5, colour="#696969") +
  theme_classic2()   +
  theme(legend.position = "bottom",
  panel.grid.major.x = element_line(colour="grey92", size=0.5, linetype="dashed"),
  strip.background = element_rect(fill = "grey92", 
                colour = "black", size = 1)
  )

## Collection_hist
gg.spp <- as_tibble(sample_data(ps2)) %>%
  dplyr::rename(label = psyllid_spp) %>%
  group_by(label) %>%
  summarise(n_species = n()) %>%
  left_join(p$data %>%
  filter(isTip) %>% select(c(label, y))) %>%
  filter(!is.na(y)) %>%
  ggplot(aes(x=factor(.$label, levels=.$label[order(.$y)]), y=1, fill=n_species)) +
  geom_tile() +
  coord_flip() + theme_void() +
  scale_fill_distiller(palette = "Reds", direction=1)
        

Fig1 + gg.spp 
  
# Change relative grid sizes
library(grid)
library(gtable)

gt = ggplot_gtable(ggplot_build(Fig1))
gt$layout$l[grep('panel-3', gt$layout$name)] # you want to find the column specific to panel-2

gt$widths[9] = 0.3*gt$widths[9] # reduce width of column 9
grid.draw(gt) # plot with grid draw

```

# Phylosymbiosis

### BDTT 

```{r timeslice}
## TRY WITHOUT ENTERO
#ps2 <- ps2 %>%
#  subset_taxa(Family  != "Enterobacteriaceae") %>%
#  filter_taxa(function(x) mean(x) > 0, TRUE)#Drop missing taxa from table
#
ps2 <- prune_samples(sample_sums(ps2) >0 , ps2)
#Look at depth categories in tree
hist(get_all_node_depths(phy_tree(ps2)))

#Set slices
slices=seq(0,1.6,0.1)

treelist <- vector("list", length=length(slices))
for (i in 1:length(slices)){
  newps <- speedyseq::tree_glom(ps2, resolution = slices[i])
  treelist[[i]] <- phy_tree(newps)
}
class(treelist) <- "multiPhylo"
names(treelist) <- paste0("Timeslice = ",slices)
gg.tree <- ggtree(treelist) + facet_wrap(~.id, scale="free", nrow=1) + theme_tree2()

Betas <- BDTT(ps2, slices, metrics=c("Bray", "Jaccard", "Aitchison", "Philr", "Unifrac", "WUnifrac"), zeroes="Impute", cores=1, quiet=FALSE)
```


### Prepare distance matrices
```{r prepare distances}
#Filter to those in ps2 
samples <- sample_names(ps2)

## Make distance matrices (cophenetic vs dist,nodes)
phylo.dist <- cophenetic(pruned.tree) %>%
  as.data.frame() %>%
  rownames_to_column("psyllid_spp.x") %>%
  pivot_longer(cols=-psyllid_spp.x,
               names_to="psyllid_spp.y",
               values_to = "dist") %>%
  right_join(sample_data(ps2) %>%
              as_tibble() %>%
              dplyr::select(Sample_Name, psyllid_spp) %>%
              dplyr::rename(psyllid_spp.x = psyllid_spp, Sample_Name.x = Sample_Name),
            by="psyllid_spp.x")%>%
  right_join(sample_data(ps2) %>%
              as_tibble() %>%
              dplyr::select(Sample_Name, psyllid_spp) %>%
              dplyr::rename(psyllid_spp.y = psyllid_spp, Sample_Name.y = Sample_Name),
            by="psyllid_spp.y") %>%
  filter(!is.na(dist))%>%
  dplyr::select(-psyllid_spp.y, -psyllid_spp.x) %>%
  pivot_wider(names_from = Sample_Name.y, values_from = dist) %>%
  magrittr::set_rownames(.$Sample_Name.x) %>%
  dplyr::select(-Sample_Name.x)%>%
  as.matrix()

# COI Genetic distance
coi.dist <- read_csv("sample_data/genetic_distance.csv", col_names = TRUE) %>%
  column_to_rownames("SampleID") 
coi.dist[upper.tri(coi.dist)] <- 0
coi.dist<- coi.dist + t(coi.dist)
coi.dist[is.na(coi.dist)] <- 0

coi.dist <- coi.dist %>%
  magrittr::set_colnames(rownames(.) %>% str_replace(pattern="\\_S(.*)$",replacement="") %>% make.unique()) %>%
  rownames_to_column("SampleID") %>%
  mutate(SampleID = SampleID %>% str_replace(pattern="\\_S(.*)$",replacement="") %>% make.unique()) %>%
  filter(SampleID %in% samples) %>%
  arrange(match(SampleID, samples)) %>%
  column_to_rownames("SampleID") %>%
  dplyr::select(one_of(samples)) %>%
  as.matrix()

# Hostplant distance
plant.dist <- read_csv("sample_data/plant_distance.csv") %>%
  dplyr::select(-one_of("X1", "Host plants")) %>%
  column_to_rownames("SampleID") %>%
  magrittr::set_colnames(rownames(.) %>% str_replace(pattern="\\_S(.*)$",replacement="") %>% make.unique()) %>%
  rownames_to_column("SampleID") %>%
  mutate(SampleID = SampleID %>% str_replace(pattern="\\_S(.*)$",replacement="") %>% make.unique()) %>%
  filter(SampleID %in% samples) %>%
  arrange(match(SampleID, samples)) %>%
  column_to_rownames("SampleID") %>%
  dplyr::select(one_of(samples))%>%
  as.matrix()


#Make spatial distance matrix
envData <- sample_data(ps2) %>%
  as_tibble() %>%
  dplyr::select(Sample_Name, lat, long) %>%
  magrittr::set_rownames(.$Sample_Name) %>%
  dplyr::select(-Sample_Name) %>%
  drop_na()

spat.dist <- spDists(as.matrix(envData), longlat=TRUE) %>%
  as.data.frame() %>%
  magrittr::set_rownames(rownames(envData) %>% str_replace(pattern="\\_S(.*)$",replacement="") %>% make.unique()) %>%
  magrittr::set_colnames(rownames(envData) %>% str_replace(pattern="\\_S(.*)$",replacement="") %>% make.unique()) %>%
  rownames_to_column("SampleID") %>%
  mutate(SampleID = SampleID %>% str_replace(pattern="\\_S(.*)$",replacement="") %>% make.unique()) %>%
  filter(SampleID %in% samples) %>%
  arrange(match(SampleID, samples)) %>%
  column_to_rownames("SampleID") %>%
  dplyr::select(one_of(samples))%>%
  as.matrix()
```

### Adonis tests
```{r Adonis}
# Construct sequence table
predictors="psyllid_spp"
StatsRes=expand.grid(similarity_slices=as.character(slices), predictors=predictors, metric=dimnames(Betas)[[2]])
StatsRes[["F.Model"]]=StatsRes[["R2"]]=StatsRes[["Pr(>F)"]]=NA
head(StatsRes)

samples <- rownames(otu_table(ps2)) 
metadata <- sample_data(ps2) %>%
  as_data_frame()

# Generalise to work with multiple predictors
i=1
for (i in as.character(slices)){
  #Jaccard
  res=unlist(adonis(Betas[i,"Jaccard",samples,samples]~ psyllid_spp, method = "euclidean", data = metadata)$aov.tab[1,c(6,5,4)])
  StatsRes[(StatsRes$metric=="Jaccard")&(StatsRes$similarity_slices==i),4:6]=res
  #Bray Curtis
  res=unlist(adonis(Betas[i,"Bray",samples,samples]~ psyllid_spp, method = "euclidean", data = metadata)$aov.tab[1,c(6,5,4)])
  StatsRes[(StatsRes$metric=="Bray")&(StatsRes$similarity_slices==i),4:6]=res
  #Aitchison
  res=unlist(adonis(Betas[i,"Aitchison",samples,samples]~ psyllid_spp, method = "euclidean", data = metadata)$aov.tab[1,c(6,5,4)])
  StatsRes[(StatsRes$metric=="Aitchison")&(StatsRes$similarity_slices==i),4:6]=res
  #Philr
  res=unlist(adonis(Betas[i,"Philr",samples,samples]~ psyllid_spp, method = "euclidean", data = metadata)$aov.tab[1,c(6,5,4)])
  StatsRes[(StatsRes$metric=="Philr")&(StatsRes$similarity_slices==i),4:6]=res
  #Unifrac
  res=unlist(adonis(Betas[i,"Unifrac",samples,samples]~ psyllid_spp, method = "euclidean", data = metadata)$aov.tab[1,c(6,5,4)])
  StatsRes[(StatsRes$metric=="Unifrac")&(StatsRes$similarity_slices==i),4:6]=res
  #WUnifrac
  res=unlist(adonis(Betas[i,"WUnifrac",samples,samples]~ psyllid_spp, method = "euclidean", data = metadata)$aov.tab[1,c(6,5,4)])
  StatsRes[(StatsRes$metric=="WUnifrac")&(StatsRes$similarity_slices==i),4:6]=res
}

# Profile for all
gg.adonis <- ggplot(StatsRes, aes(y=R2, x=similarity_slices, colour=predictors, group=factor(predictors)))+
  geom_point() +
  geom_line() +
  facet_wrap(~metric)

```

### Mantel tests
```{r Mantel} 
samples <- rownames(otu_table(ps2))
dists <- c("phylo.dist","coi.dist","plant.dist", "spat.dist")
mantlist_distances <- vector("list", length=length(dists))

# Generalise these to a function. Get names from the slices object


for (d in 1:length(dists)){
  test.dist <- get(dists[d])

  samples_to_use <- samples[samples %in% colnames(as.matrix(test.dist))]
  
  manlist <- vector("list", length=length(slices))
  for (i in 1:length(slices)){
    
    nslice <- as.character(slices[i])
    print(paste0(nslice, " for ", dists[d]))
    #Jac
    man_jac <- mantel(Betas[nslice,"Jaccard",samples_to_use,samples_to_use], test.dist[samples_to_use,samples_to_use])
    #Bray
    man_bray<- mantel(Betas[nslice,"Bray",samples_to_use,samples_to_use], test.dist[samples_to_use,samples_to_use])
    #Aitch
    man_aitch <- mantel(Betas[nslice,"Aitchison",samples_to_use,samples_to_use], test.dist[samples_to_use,samples_to_use])
    #PhilR
    man_philr <- mantel(Betas[nslice,"Philr",samples_to_use,samples_to_use], test.dist[samples_to_use,samples_to_use])
    #Unifrac
    man_unifrac <- mantel(Betas[nslice,"Unifrac",samples_to_use,samples_to_use], test.dist[samples_to_use,samples_to_use])
    #Weighted Unifrac
    man_wunifrac <- mantel(Betas[nslice,"WUnifrac",samples_to_use,samples_to_use], test.dist[samples_to_use,samples_to_use])

    manlist[[i]] <- tribble(
      ~metric, ~stat, ~signif,
      "Jaccard (Qualitative)", man_jac$statistic, man_jac$signif,
      "Bray-Curtis(Quantitative)", man_bray$statistic, man_bray$signif,
      "Aitchison (Quantitative, Compositional)", man_aitch$statistic, man_aitch$signif,
      "PhilR (Quantitative, Phylogenetic, Compositional)", man_philr$statistic, man_philr$signif,
      "Unifrac (Qualitative, Phylogenetic)", man_unifrac$statistic, man_unifrac$signif,
      "Weighted Unifrac (Quantitative, Phylogenetic)", man_wunifrac$statistic, man_wunifrac$signif
    ) %>%
      mutate(distance=dists[d], slice=slices[i])
  }
  mantlist_distances[[d]] <- bind_rows(manlist)
}

gg.mantel <- bind_rows(mantlist_distances) %>%
  mutate(Comparison = paste0("microbe~",distance)) %>%
  ggplot(aes(y=stat,x=slice, colour=distance, group=factor(distance))) +
  geom_path(linetype="dashed")+
  geom_line(data=bind_rows(mantlist_distances) %>% mutate(stat = case_when (signif > 0.01 ~ as.double(NA), signif < 0.01 ~ stat)), linetype="solid") +
  geom_hline(yintercept=0) +
  facet_wrap(~metric) +
     #theme_classic2()   +
     theme(legend.position = "right",
           panel.grid.major.y = element_line(colour="grey", size=0.5, linetype="dashed"),
           strip.background = element_rect(fill = "grey92", 
                                           colour = "black", size = 1)
     )  + scale_color_brewer(palette="Paired")
```

### Partial mantel tests
```{r Partial Mantel}
samples <- rownames(otu_table(ps2))
dists <- expand_grid(dist1 = c("phylo.dist","coi.dist", "plant.dist", "spat.dist"), dist2=c("phylo.dist","plant.dist", "spat.dist")) %>%
  filter(!dist1==dist2)
PMlist_distances <- vector("list", length=length(dists))

for (d in 1:nrow(dists)){
  test.dist <- get(dists$dist1[d])
  control.dist <- get(dists$dist2[d])
  
  samples_to_use <- samples[samples %in% colnames(as.matrix(test.dist))]
  samples_to_use <- samples_to_use[samples_to_use %in% colnames(as.matrix(control.dist))]
  
  PMlist <- vector("list", length=length(slices))
  for (i in 1:length(slices)){
    
    nslice <- as.character(slices[i])
    print(paste0(nslice, " for ",dists$dist1[d], " ~ ", dists$dist2[d]))
    #Jac
    PM_jac <- mantel.partial(Betas[nslice, "Jaccard", samples_to_use, samples_to_use],
                         test.dist[samples_to_use, samples_to_use],
                          control.dist[samples_to_use, samples_to_use])
    
    #Bray
    PM_bray <- mantel.partial(Betas[nslice,"Bray",samples_to_use,samples_to_use],
                         test.dist[samples_to_use,samples_to_use],
                         control.dist[samples_to_use,samples_to_use])
    #Aitch
    PM_aitch <- mantel.partial(Betas[nslice,"Aitchison",samples_to_use,samples_to_use], 
                         test.dist[samples_to_use,samples_to_use], 
                         control.dist[samples_to_use,samples_to_use])
    #Philr
    PM_philr <- mantel.partial(Betas[nslice,"Philr",samples_to_use,samples_to_use], 
                         test.dist[samples_to_use,samples_to_use], 
                         control.dist[samples_to_use,samples_to_use])
    #Unifrac
    PM_unifrac <- mantel.partial(Betas[nslice,"Unifrac",samples_to_use,samples_to_use], 
                         test.dist[samples_to_use,samples_to_use], 
                         control.dist[samples_to_use,samples_to_use])
    #Weighted Unifrac
    PM_wunifrac <- mantel.partial(Betas[nslice,"WUnifrac",samples_to_use,samples_to_use], 
                         test.dist[samples_to_use,samples_to_use], 
                         control.dist[samples_to_use,samples_to_use])
    PMlist[[i]] <- tribble(
      ~metric, ~stat, ~signif,
      "Jaccard (Qualitative)", PM_jac$statistic, PM_jac$signif,
      "Bray (Quantitative)", PM_bray$statistic, PM_bray$signif,
      "Aitchison (Quantitative, Compositional)", PM_aitch$statistic, PM_aitch$signif,
      "PhilR (Quantitative, Phylogenetic, Compositional)", PM_philr$statistic, PM_philr$signif,
      "Unifrac (Qualitative, Phylogenetic)", PM_unifrac$statistic, PM_unifrac$signif,
      "Weighted Unifrac (Quantitative, Phylogenetic)", PM_wunifrac$statistic, PM_wunifrac$signif
    ) %>%
      mutate(dist1=dists$dist1[d], dist2=dists$dist2[d], slice=slices[i])
    }
  PMlist_distances[[d]] <- bind_rows(PMlist)
}


gg.pmantel <- bind_rows(PMlist_distances) %>%
  mutate(Comparison = paste0("microbe~",dist1,"~",dist2)) %>%
  ggplot(aes(y=stat, x=slice, colour=Comparison, group=factor(Comparison)))+ 
  geom_line(linetype="dashed") +
  geom_line(data=bind_rows(PMlist_distances) %>% mutate(Comparison = paste0("microbe~",dist1,"~",dist2)) %>% mutate(stat = case_when (signif > 0.01 ~ as.double(NA), signif < 0.01 ~ stat)), linetype="solid") +
  geom_hline(yintercept=0) +
  facet_wrap(~metric) +
     #theme_classic2()   +
     theme(legend.position = "right",
           panel.grid.major.y = element_line(colour="grey", size=0.5, linetype="dashed"),
           strip.background = element_rect(fill = "grey92", 
                                           colour = "black", size = 1)
     )  + scale_color_brewer(palette="Paired")

```

### Tree topology comparison

Heirarchial clustering 
robinson foulds, matching cluster

But also see how this paper has done it with PACO https://www.nature.com/articles/s41467-019-10191-3.pdf Using random subsampling? Then pull out the most associated also file:///C:/Users/ap0y/Dropbox/workprojects/Papers/10.1002_ecy.1955.pdf
```{r topology comparison}
samples <- rownames(otu_table(ps2))
dists <- c("phylo.dist","plant.dist", "spat.dist")
mantlist_distances <- vector("list", length=length(dists))

for (d in 1:length(dists)){
  test.dist <- get(dists[d])
  
  samples_to_use <- samples[samples %in% colnames(as.matrix(test.dist))]
  
  manlist <- vector("list", length=length(slices))
  for (i in 1:length(slices)){
    
    nslice <- as.character(slices[i])
    #Jac
    hc <- (as.phylo(hclust(as.dist(Betas[nslice,"Jac",samples_to_use,samples_to_use]), method="ward.D2")))
    
    # random tree
    rtree(length(hc$tip.label), rooted=FALSE)
    
    
    dist.topo(as.phylo(hclust(as.dist(Betas[nslice,"Jac",samples_to_use,samples_to_use]), method="ward.D2"), directed=FALSE),
              y = as.phylo(hclust(as.dist(test.dist[samples_to_use,samples_to_use]), method="ward.D2")), method = "PH85")
    
    dist.topo(as.phylo(hclust(as.dist(Betas[nslice,"Jac",samples_to_use,samples_to_use]), method="ward.D2")),
              y = as.phylo(hclust(as.dist(test.dist[samples_to_use,samples_to_use]), method="ward.D2")), method = "PH85")

    
    proc <- protest(monoMDS(Betas[nslice,"Jac",samples_to_use,samples_to_use]), monoMDS(test.dist[samples_to_use,samples_to_use]))
    proc_jac <- data.frame(metric="Jac", test=dists[d], stat=proc$t0, scale=proc$scale, signif=proc$signif)
    #Bray
    proc <- protest(monoMDS(Betas[nslice,"Bray",samples_to_use,samples_to_use]), monoMDS(test.dist[samples_to_use,samples_to_use]))
    proc_bray <- data.frame(metric="Bray", test=dists[d], stat=proc$t0, scale=proc$scale, signif=proc$signif)
    #Aitch_psedo
    proc <- protest(monoMDS(Betas[nslice,"Aitch_pseudo",samples_to_use,samples_to_use]), monoMDS(test.dist[samples_to_use,samples_to_use]))
    proc_aitch_pseudo <- data.frame(metric="Aitch_pseudo", test=dists[d], stat=proc$t0, scale=proc$scale, signif=proc$signif)
    #Aitch_rep
    proc <- protest(monoMDS(Betas[nslice,"Aitch_pseudo",samples_to_use,samples_to_use]), monoMDS(test.dist[samples_to_use,samples_to_use]))
    proc_aitch_rep <- data.frame(metric="Aitch_rep", test=dists[d], stat=proc$t0, scale=proc$scale, signif=proc$signif)
    manlist[[i]] <- bind_rows(proc_jac, proc_bray, proc_aitch_pseudo, proc_aitch_rep) %>%
      mutate(slice=slices[i])
  }
  mantlist_distances[[d]] <- bind_rows(manlist)
}

matrix_stats <- bind_rows(mantlist_distances) %>%
  mutate(signif_test = case_when(
    signif < 0.01 ~ TRUE,
    signif > 0.01 ~ FALSE
  ))
gg.mantel <- ggplot(matrix_stats, aes(y=stat,x=slice, colour=test, group=factor(test)))+
  geom_point(aes(shape=signif_test)) +
  geom_line()+ 
  geom_hline(yintercept=0) +
  facet_wrap(~metric) 


```

# Cophylogeny


## Psyllid hostplant cophylogeny

```{r}


```

## Whole dataset cophylogeny

```{r randomtapas}
## Prepare interaction table
# Merge species
ps.sppmerged <- ps2 %>%
    merge_samples(group = "psyllid_spp")

sample_data(ps.sppmerged) <- read.csv("sample_data/Sample_info.csv", header=TRUE) %>%
  filter(!duplicated(psyllid_spp)) %>%
  set_rownames(.$psyllid_spp) %>%
  dplyr::select(c("SampleID", "Sample_Name", "seqrun", "psyllid_spp", "psyllid_genus", "psyllid_family", "hostplant_spp","Collection","Collection.Date"))

# subset to just carsonella
#ps.sppmerged <- ps.sppmerged %>%
#  subset_taxa( Genus == "Candidatus_Carsonella"
#  )

ps4 <- filter_taxa(ps.sppmerged, function(x) mean(x) > 0, TRUE) #Drop missing taxa from table

#Rename taxa
#taxa_names(ps4) <- paste0("SV", seq(ntaxa(ps4)),"-",tax_table(ps4)[,6])

#rename problem samples
sample_names(ps4) <- sample_names(ps4) %>% str_replace_all("'","")

otu <- ps4 %>%
    otu_table %>%
    as.matrix() %>% 
  apply(2, function(x) ifelse(x > 0, 1, 0))

                  
#Cophenetic distance
psyllid_tree <- read.tree(text=readLines("sample_data/psyllid_beast_tree.nwk"))

# Match names with alpha diversity
psyllid_tree$tip.label <- psyllid_tree$tip.label %>%
  str_replace_all(pattern="\\.", replacement=" ") %>%
  str_replace_all(pattern="sp$", replacement="sp. ") %>%
  str_replace_all(pattern="Acizzia hakae", replacement="Acizzia hakeae") %>%
  str_replace_all(pattern="POLLENISLAND", replacement="POLLEN ISLAND") %>%
  str_replace_all(pattern="Ctenarytaina fuchsiae$", replacement="Ctenarytaina fuchsia A") %>%
  str_replace_all(pattern="Ctenarytaina fuchsiaeB", replacement="Ctenarytaina fuchsia B") %>%
  str_replace_all(pattern="Ctenarytaina fuchsiaeC", replacement="Ctenarytaina fuchsia C") %>%
  str_replace_all(pattern="Ctenarytaina clavata", replacement="Ctenarytaina clavata sp. ") %>%
  str_replace_all(pattern="Ctenarytaina clavata sp. $", replacement="Ctenarytaina clavata sp. A") %>%
  str_replace_all(pattern="Ctenarytaina sp$", replacement="Ctenarytaina sp. ") %>%
  str_replace_all(pattern="Ctenarytaina unknown", replacement="Ctenarytaina insularis") %>%  
  str_replace_all(pattern="Psylla apicalis A", replacement="Psylla frodobagginsi") %>%
  str_replace_all(pattern="Psylla apicalis B", replacement="Psylla apicalis") %>%
  str_replace_all(pattern="carmichaeliae", replacement="carmichaeliae ") %>%
  str_replace_all(pattern="Psylla apicalis", replacement="Psylla apicalis ") %>% # Should these be A,B or?
  str_replace_all(pattern="Trioza sp", replacement="Trioza sp. ") %>%
  str_replace_all(pattern="Trioza acutaB", replacement="Trioza Acuta B") %>%
  str_replace_all(pattern="BRENDAMAY", replacement="BRENDA MAY") %>%
  str_replace_all(pattern="PRICES", replacement="PRICES VALLEY") %>%
  trimws(which="right")

psyllid_tree$tip.label[!psyllid_tree$tip.label %in% rownames(otu)]

pruned.tree <- drop.tip(psyllid_tree, psyllid_tree$tip.label[!psyllid_tree$tip.label %in% rownames(otu)] )
psyllid_tree$tip.label[!psyllid_tree$tip.label %in%  pruned.tree$tip.label]

#cophenetic <- cophenetic(pruned.tree)

HS <- otu[pruned.tree$tip.label,]
mode(HS) <- "integer"
TreeH <- pruned.tree
TreeS <- phy_tree(ps4)

# Optional: Draw a tanglegram - filter this beforehand

HS.lut <- which(HS ==1, arr.ind=TRUE)
linkhs <- cbind(rownames(HS)[HS.lut[,1]], colnames(HS)[HS.lut[,2]])
linkhs[,1] <- str_replace_all(linkhs[,1], " ", "_")
obj <- cophylo(tr1=TreeH, tr2=TreeS, assoc=linkhs, rotate=TRUE) 
plot.cophylo(obj, link.lwd=1, link.lty=2, fsize=0.5, pts=FALSE, link.type="curved")
dev.off() #reset graphics device


# 1. Find minimum value with which all runs can be completed - Establish N
#Recommended= N= 1e+4
N= 100
One2one.f(HS,N) 

# N should be close	to	20%,	or	at	least	10%,	of	the	total	number	of	associations
# For our dataset number of associations = (length(TreeS$tip.label)) = 3042 * 0.2 = 608.4 
# We can evaluate a range if we want
X <- seq(10,50,5)
Y <- rep(NA, length(X))
for(i in 1:length(X)) {
  THS <- trimHS.maxC(N, HS, n=X[i], check.unique=TRUE)
  Y[i] <- length(THS)
}
plot(X,Y, type="b", xlab="Number of unique H-S associations",
     ylab="Number of runs accomplished")
# 3. We choose 8
n=54
THS <- trimHS.maxC(N, HS, n=n, check.unique=TRUE)
THS[sapply(THS, is.null)] <- NULL

####### Apply 2 global-fit methods: GD and PACo ##########
# NOTE PACo symmetric= TRUE in this example!!!!
GD <- sapply(THS, geo.D, treeH=TreeH, treeS= TreeS)
PACO <- sapply(THS, paco.ss, treeH=TreeH, treeS= TreeS, ei.correct= "sqrt.D",
               symmetric=TRUE)
#
######### extract h-s association frequencies
LFGD01 <- link.freq(THS, GD, HS, percentile=0.01)
LFPACO01 <- link.freq(THS, PACO, HS, percentile=0.01)
#
```



## Carsonella copylogeny

Maybe this should be done just for carsonella tree

These samples were sequenced using combinatorial indexes. Therefore this data will contain index switching. We therefore need to select an optimal filtering threshold to remove switched taxa, but not real taxa. We will optimise our filtering threshold by relying on assumption that all psyllid species should contain only one (or few very closely related ASVs) of Carsonella.

```{r thresholds}

ps2.carson <- ps2 %>% subset_taxa( Genus == "Candidatus_Carsonella")

#Rename taxa
taxa_names(ps2.carson) <- paste0("SV", seq(ntaxa(ps2.carson)),"-",tax_table(ps2.carson)[,6])

#Flag top abundance carsonella
top_carson <-  ps2.carson %>%
  transform_sample_counts(function (x) x/sum(x)) %>%
  speedyseq::psmelt() %>%
  filter(Genus=="Candidatus_Carsonella") %>%
  group_by(Sample) %>%
  top_n(1, wt=Abundance) %>%
  mutate(top = TRUE)  %>%
  filter(Abundance > 0)
  
#Flag lower abundance carsonella
carson <-  ps2.carson %>%
  transform_sample_counts(function (x) x/sum(x)) %>%
  speedyseq::psmelt() %>%
  filter(Genus=="Candidatus_Carsonella") %>%
  left_join(top_carson) %>%
  mutate(top = case_when(
    is.na(top) ~ FALSE,
    !is.na(top) ~ top
  ))

## THis needs to be changed - things should be flagged as switched when less than 100* the top!, or combine both - ie 

test <- carson %>%
    filter(Abundance > 0) %>%
    dplyr::select(OTU, top, seqrun, Abundance) %>%
    unique() %>%
    group_by(OTU, seqrun) %>%
    add_tally() %>%
    mutate(switched = case_when(
      n>1 & top== FALSE  ~ TRUE,
      n>1 & top== TRUE ~ FALSE,
      n==1 ~ FALSE,
    ))


otu <- carson %>%
  left_join(test) %>%
  dplyr::select(-n) %>%
  filter(Genus=="Candidatus_Carsonella", top==TRUE) %>%
  select(OTU, psyllid_spp, SampleID, Abundance) %>%
  dplyr::group_by(OTU, psyllid_spp) %>%
    summarise(Abundance = sum(Abundance)) %>%
  pivot_wider(id_cols = psyllid_spp,
              names_from = OTU,
              values_from=Abundance,
              values_fill = list(Abundance = 0))  %>%
  column_to_rownames("psyllid_spp") %>%
    as.matrix() %>% 
  apply(2, function(x) ifelse(x > 0, 1, 0))


#Cophenetic distance
psyllid_tree <- read.tree(text=readLines("sample_data/psyllid_beast_tree.nwk"))

# Match names with alpha diversity
psyllid_tree$tip.label <- psyllid_tree$tip.label %>%
  str_replace_all(pattern="\\.", replacement=" ") %>%
  str_replace_all(pattern="sp$", replacement="sp. ") %>%
  str_replace_all(pattern="Acizzia hakae", replacement="Acizzia hakeae") %>%
  str_replace_all(pattern="POLLENISLAND", replacement="POLLEN ISLAND") %>%
  str_replace_all(pattern="Ctenarytaina fuchsiae$", replacement="Ctenarytaina fuchsia A") %>%
  str_replace_all(pattern="Ctenarytaina fuchsiaeB", replacement="Ctenarytaina fuchsia B") %>%
  str_replace_all(pattern="Ctenarytaina fuchsiaeC", replacement="Ctenarytaina fuchsia C") %>%
  str_replace_all(pattern="Ctenarytaina clavata", replacement="Ctenarytaina clavata sp. ") %>%
  str_replace_all(pattern="Ctenarytaina clavata sp. $", replacement="Ctenarytaina clavata sp. A") %>%
  str_replace_all(pattern="Ctenarytaina sp$", replacement="Ctenarytaina sp. ") %>%
  str_replace_all(pattern="Ctenarytaina unknown", replacement="Ctenarytaina insularis") %>%  
  str_replace_all(pattern="Psylla apicalis A", replacement="Psylla frodobagginsi") %>%
  str_replace_all(pattern="Psylla apicalis B", replacement="Psylla apicalis") %>%
  str_replace_all(pattern="carmichaeliae", replacement="carmichaeliae ") %>%
  str_replace_all(pattern="Psylla apicalis", replacement="Psylla apicalis ") %>% # Should these be A,B or?
  str_replace_all(pattern="Trioza sp", replacement="Trioza sp. ") %>%
  str_replace_all(pattern="Trioza acutaB", replacement="Trioza Acuta B") %>%
  str_replace_all(pattern="BRENDAMAY", replacement="BRENDA MAY") %>%
  str_replace_all(pattern="PRICES", replacement="PRICES VALLEY") %>%
  trimws(which="right")

psyllid_tree$tip.label[!psyllid_tree$tip.label %in% rownames(otu)]

#cophenetic <- cophenetic(pruned.tree)

HS <- otu[pruned.tree$tip.label,]
HS <- HS[,colSums(HS) > 0]
TreeH <- drop.tip(psyllid_tree, psyllid_tree$tip.label[!psyllid_tree$tip.label %in% rownames(HS)] )
TreeS <-  drop.tip(phy_tree(ps2.carson), phy_tree(ps2.carson)$tip.label[!phy_tree(ps2.carson)$tip.label %in% colnames(HS)] )

# Optional: Draw a tanglegram - filter this beforehand

HS.lut <- which(HS ==1, arr.ind=TRUE)
linkhs <- cbind(rownames(HS)[HS.lut[,1]], colnames(HS)[HS.lut[,2]])
linkhs[,1] <- str_replace_all(linkhs[,1], " ", "_")
obj <- cophylo(tr1=TreeH, tr2=TreeS, assoc=linkhs, rotate=TRUE) 
plot.cophylo(obj, link.lwd=1, link.lty=2, fsize=0.5, pts=FALSE, link.type="curved")
dev.off() #reset graphics device


# Find the maximum n for which one-to-one unique associations can be picked in trimHS.maxC over  a number of runs.
N=100
One2one.f(HS,N) 
# 2. Let's evaluate 62-75
X <- 62:75
Y <- rep(NA, length(X))

for(i in 1:length(X)) {
  THS <- trimHS.maxC(N, HS, n=X[i], check.unique=TRUE)
  Y[i] <- length(THS)
}
plot(X,Y, type="b", xlab="Number of unique H-S associations",
     ylab="Number of runs accomplished")
# 3. We choose 8
n=62
THS <- trimHS.maxC(N, HS, n=n, check.unique=TRUE)
THS[sapply(THS, is.null)] <- NULL
#

####### Apply 2 global-fit methods: GD and PACo ##########
# NOTE PACo symmetric= TRUE in this example!!!!
GD <- sapply(THS, geo.D, treeH=TreeH, treeS= TreeS)
PACO <- sapply(THS, paco.ss, treeH=TreeH, treeS= TreeS, ei.correct= "sqrt.D",
               symmetric=TRUE)
#
######### extract h-s association frequencies
LFGD01 <- link.freq(THS, GD, HS, percentile=0.01)
LFPACO01 <- link.freq(THS, PACO, HS, percentile=0.01)

# Plot Gini values
GiniGD <- unlist(Gini_RSV(LFGD01[,5]))
GiniPA <- unlist(Gini_RSV(LFPACO01[,5]))

boxplot(GiniGD, GiniPA, names = c("GD", "PACo"),
        ylab="Normalized Gini coefficient", col="lightblue", las=3)
text(1,GiniGD,"*",cex=2, col="darkblue")
text(2,GiniPA,"*",cex=2, col="darkblue")
dev.off()


# Tanglegram - trees are 1st rendered ultramteric to separate nodes
# (facilitates visualization)
trh <- compute.brtime(TreeH, TreeH$Nnode:1)
trs <- compute.brtime(TreeS, TreeS$Nnode:1)
# Set color scale - this one is supposed to be color-blind friendly
col.scale <- c("darkred","gray90", "darkblue")

# map GD results:
tangle.gram(trh, trs, HS, colscale= "diverging", colgrad=col.scale, 
            nbreaks=50, LFPACO01, res.fq=TRUE, link.lwd=1, link.lty=1, fsize=0.5,
            pts=FALSE, link.type="curved", node.tag=TRUE,
            cexpt=1.2)
```

```{r subsetting}
library(plotly)

#filter threshold to ge
#ps2.carson <- transform_sample_counts(ps2, fun = proportions, thresh=0.0045)

#ps2.carson <- subset_taxa(ps2.carson, Genus == "Candidatus_Carsonella")
#ps2.carson <- filter_taxa(ps2.carson, function(x) mean(x) > 0, TRUE) #Drop missing taxa from table
#ps2.carson <- prune_samples(sample_sums(ps2.carson)>0, ps2.carson) # Drop empty samples

library(RColorBrewer)
col <- colorRampPalette(brewer.pal(11, "Spectral"))(74)


ps2.carson <- subset_taxa(ps2, Species == "Candidatus Carsonella")
gg.carson <- plot_tree(ps2.carson, ladderize="left",  color="psyllid_spp") +   theme(legend.position = "none") + #
    scale_colour_manual(values=col) + scale_fill_manual(values=col)
  ggtitle("Carsonella 16S gene tree")
#gg.ncarson
  
## Aquabacterium
gg.tree <- plot_tree(subset_taxa(ps2, Species == "Sulfuritalea"), ladderize="left",  color="psyllid_spp") +   theme(legend.position = "none") + #
    scale_colour_manual(values=col) + scale_fill_manual(values=col)
  ggtitle("Carsonella 16S gene tree")
#gg.ncarson

#Write out fasta

carson_out <- speedyseq::psmelt(ps3.carson) %>%
  filter(Abundance > 0) %>%
  select(OTU, Sample_Name, psyllid_spp, Species) %>%
  group_by(OTU, Species) %>%
  summarize(samples = paste(Sample_Name, collapse=";"),
            psyllid_spp = paste(unique(psyllid_spp), collapse=";")
            ) %>%
  rownames_to_column() %>%
  unite(seqname, c("Species","rowname","psyllid_spp","samples"), sep="|")

carson_fasta <- DNAStringSet(carson_out$OTU)
names(carson_fasta) <- carson_out$seqname

writeXStringSet(carson_fasta, "carsonella_seqs.fa")


## S-Symbionts
ps3.carson <- subset_taxa(ps3, Family == "Enterobacteriaceae")
taxa_names(ps3.carson) <- paste0("SV", seq(ntaxa(ps3.carson)),"-",tax_table(ps3.carson)[,7])

gg.entero <- plot_tree(ps3.carson, ladderize="left",  color="psyllid_spp", label.tips="taxa_names") +   theme(legend.position = "none") +     #scale_colour_manual(values=col) +
  ggtitle("Enterobacidae 16S gene tree")

#, label.tips="psyllid_spp

```

Use paco https://besjournals.onlinelibrary.wiley.com/doi/full/10.1111/2041-210X.12736

and Parafit https://www.rdocumentation.org/packages/ape/versions/5.3/topics/parafit

```{r paco}

## Plotting - arrange by tree

## Paco needs:

## Co-occurance matrix
# otu abundance matrix
ps2.glom <- ps2 %>% 
    tip_glom(h=0.3)

otu <- ps2.glom %>%
    otu_table %>%
    as.data.frame %>%
    rownames_to_column("SampleID") %>%
    filter(SampleID %in% rownames(host_dist)) %>%
    arrange(match(SampleID, rownames(host_dist))) %>%
    mutate(total=rowSums(select_if(., is.numeric))) %>%
    filter(total > 0) %>%
    dplyr::select(-total) %>%
    column_to_rownames("SampleID") %>%
  as.matrix

# convert to binary
otu <- otu %>% apply(2, function(x) ifelse(x > 0, 1, 0)) %>% as.matrix
                    

# 1 - host phylogenetic distance matrix
phylo.dist


#Cophenetic distance
#psyllid_tree <- read.tree(text=readLines("sample_data/psyllid_beast_tree.nwk"))

# Match names with alpha diversity
#psyllid_tree$tip.label <- psyllid_tree$tip.label %>%
#  str_replace_all(pattern="\\.", replacement=" ") %>%
#  str_replace_all(pattern="sp$", replacement="sp. ") %>%
#  str_replace_all(pattern="Acizzia hakae", replacement="Acizzia hakeae") %>%
#  str_replace_all(pattern="POLLENISLAND", replacement="POLLEN ISLAND") %>%
#  str_replace_all(pattern="Ctenarytaina fuchsiae$", replacement="Ctenarytaina fuchsia A") %>%
#  str_replace_all(pattern="Ctenarytaina fuchsiaeB", replacement="Ctenarytaina fuchsia B") %>%
#  str_replace_all(pattern="Ctenarytaina fuchsiaeC", replacement="Ctenarytaina fuchsia C") %>%
#  str_replace_all(pattern="Ctenarytaina clavata", replacement="Ctenarytaina clavata sp. ") %>%
#  str_replace_all(pattern="Ctenarytaina clavata sp. $", replacement="Ctenarytaina clavata sp. A") %>%
#  str_replace_all(pattern="Ctenarytaina sp$", replacement="Ctenarytaina sp. ") %>%
#  str_replace_all(pattern="Ctenarytaina unknown", replacement="Ctenarytaina insularis") %>%  
#  str_replace_all(pattern="Psylla apicalis A", replacement="Psylla frodobagginsi") %>%
#  str_replace_all(pattern="Psylla apicalis B", replacement="Psylla apicalis") %>%
#  str_replace_all(pattern="carmichaeliae", replacement="carmichaeliae ") %>%
#  str_replace_all(pattern="Psylla apicalis", replacement="Psylla apicalis ") %>% # Should these be A,B or?
#  str_replace_all(pattern="Trioza sp", replacement="Trioza sp. ") %>%
#  str_replace_all(pattern="Trioza acutaB", replacement="Trioza Acuta B") %>%
#  str_replace_all(pattern="BRENDAMAY", replacement="BRENDA MAY") %>%
#  str_replace_all(pattern="PRICES", replacement="PRICE'S VALLEY") %>%
#  trimws(which="right")
#
#
#psyllid_tree$tip.label[!psyllid_tree$tip.label %in% bt_randomdf$psyllid_spp]
#
#pruned.tree <- drop.tip(psyllid_tree, psyllid_tree$tip.label[!psyllid_tree$tip.label %in% bt_randomdf$psyllid_spp] )
#psyllid_tree$tip.label[!psyllid_tree$tip.label %in%  pruned.tree$tip.label]
#
#cophenetic <- cophenetic(pruned.tree)

# 2 - Microbe distance matrix (cophenetic?)
micro_phylo <- cophenetic(phy_tree(ps2.glom))



# Compare distributions

phylo.dist %>% as.vector %>% summary %>% print
micro_phylo %>% as.vector %>% summary %>% print
                    

host_dist <- phylo.dist %>% as.matrix

setdiff(rownames(host_dist), rownames(otu))
setdiff(rownames(otu), rownames(host_dist))

otu
# prepare paco data
D = prepare_paco_data(H=phylo.dist %>% as.matrix, P=micro_phylo, HP=otu)
D %>% names

# Add pcord

D = add_pcoord(D, correction='cailliez')
D %>% names

D$H_PCo %>% as.vector %>% summary %>% print
D$P_PCo %>% as.vector %>% summary %>% print

# plot Principal coordinates
neg_to_pos_eig = function(PCo){
    min_val = PCo %>% as.vector %>% min
    print(min_val)
    if(min_val < 0){
        PCo = PCo + abs(min_val)
    }
    return(PCo)
}

D$H_PCo = neg_to_pos_eig(D$H_PCo)
D$P_PCo = neg_to_pos_eig(D$P_PCo)

# status
D$H_PCo %>% as.vector %>% summary %>% print
D$P_PCo %>% as.vector %>% summary %>% print

tmp = D$H_PCo[,c('Axis.1', 'Axis.2')] %>% as.data.frame
p_host = ggplot(tmp, aes(Axis.1, Axis.2)) +
    geom_point() +
    theme_bw()

tmp = D$P_PCo[,c('Axis.1', 'Axis.2')] %>% as.data.frame
p_micro = ggplot(tmp, aes(Axis.1, Axis.2))  +
    geom_point() +
    theme_bw()
    
plot(p_micro)
plot(p_host)

# run paco
paco_shortrun <- PACo(D, nperm=99, seed=39473, method='quasiswap', symmetric=TRUE)

paco_residuals <- residuals_paco(paco_shortrun$proc, type = "interaction")

paco_l <- paco_links(paco_shortrun)

paco_run <- PACo(D, nperm=999, seed=39473, method='r0', symmetric=FALSE)

# Visualise residuals
res <- data.frame(res=paco_residuals) %>%
  rownames_to_column("OTU") %>%
  separate(OTU, into=c("SampleID", "OTU")) %>%
  left_join(as.data.frame(tax_table(ps2)) %>%
              rownames_to_column("OTU"), by="OTU")
ggplot(res, aes(x=res))+
  geom_density(fill='grey70')+
  facet_wrap(~Phylum) +
  theme_bw()+
  xlab('Procrustes residuals')+
  ylab('Frequency')

# Cophyloplot requires 2 phylo objects, and a matrix with 2 columns specifying the associations between the tips

assoc <- data.frame(pol=rownames(otu)[which(int==otu, arr.ind=TRUE)[,'row']], pla=colnames(int)[which(int==1, arr.ind=TRUE)[,'col']])
# to weight the interactions we use the cophylogenetic contribution transformed to best show
# the differences graphically
weight <- (res^-2)/50

cophyloplot(poll_phy, pla_phy, otu, show.tip.label=FALSE, use.edge.length=FALSE,
	lwd=weight, col='steelblue', length.line=0, gap=-20, space=60)


# Welch's t-test to test the difference between cophylogenetic signal of interactions
ttest <- t.test(cophy, noncophy)

# visualise the difference with a box and whisker plot
dat <- rbind(data.frame(cophy=cophy, level='high'), data.frame(cophy=noncophy, level='rest'))
ggplot(dat, aes(x=level, y=cophy, fill=level))+
geom_boxplot(alpha=0.85)+
scale_fill_brewer(palette='Paired')+
scale_x_discrete(labels=c('L-M/O','Rest'))+
ylab('Procrustes residual')+
theme_bw()+
theme(
	axis.title.x=element_blank(),
	panel.grid=element_blank(),
	legend.position='none',
	axis.text.x=element_text(size=14),
	axis.title.y=element_text(size=14)
	)

# test the influence of degree on cophylogenetic signal
special <- data.frame(cophy.sig=res, pla_deg=NA, row.names=names(res))
f <- function(x) length(grep(strsplit(x, '-')[[1]][2], names(res)))
special$pla_deg <- sapply(rownames(special), f)

plant_degree <- summary(lm(cophy.sig ~ pla_deg, data=special))


# See how the global fit of the procrustes analysis changes over
# NExt - subset to each family and Conduct procrustes
# Next subset to the highest genus and try procrustes? 
# alternatively, could split tree at different phylogenetic levels and do it? Family is probably more sensible
```

## Map of colleciton locations

```{r Collection map}
#Make spatial distance matrix
library(sp)
 # Spatial distance
  envData <- read.csv("sample_data/Sample_info.csv", header=TRUE)  %>%
    dplyr::filter(!duplicated(SampleID)) %>%
    set_rownames(.$SampleID) %>%
    separate(Collection, into= c("Lat", "Long"), sep=" ", remove = FALSE) %>%
    separate(Lat, paste("lat",c("d","m","s"), sep="_") ) %>%
    separate(Long, paste("long",c("d","m","s"), sep="_" ) ) %>%
    mutate_at(vars(-SampleID, -psyllid_spp), funs(as.numeric)) %>%
    mutate(lat=-(lat_d + lat_m/60 + lat_s/60^2),
              long=long_d + long_m/60 + long_s/60^2) %>%
    dplyr::select(SampleID, psyllid_spp, lat, long) %>%
    column_to_rownames("SampleID") %>%
    drop_na()

#Plot on map to confirm points
library("maptools")
data(wrld_simpl)
wrld_simpl@data$id <- wrld_simpl@data$NAME
wrld <- fortify(wrld_simpl, region="id")

gg.worldmap <- ggplot(envData) +
  geom_map(data=wrld, map=wrld, aes(map_id=id, x=long, y=lat), fill="lightgrey", color="#7f7f7f", size=0.25) +
  geom_point(aes(x=long, y=lat, color=psyllid_spp), alpha=.5, size=3) + 
  theme_bw() +
  coord_fixed(ylim = c(-90,90), xlim=c(-180,180))  

gg.anzmap <- ggplot(envData) +
  geom_map(data=wrld, map=wrld, aes(map_id=id, x=long, y=lat), fill="lightgrey", color="#7f7f7f", size=0.25) +
  geom_point(aes(x=long, y=lat, color=psyllid_spp), alpha=.5, size=3) + 
  theme_bw() +
  coord_fixed(ylim = c(-50,-30), xlim=c(130,180))+
  theme(legend.position = "bottom")  


gg.nzmap <- ggplot(envData) +
  geom_map(data=wrld, map=wrld, aes(map_id=id, x=long, y=lat), fill="lightgrey", color="#7f7f7f", size=0.25) +
  geom_point(aes(x=long, y=lat, color=psyllid_spp), alpha=.5, size=3) + 
  theme_bw() +
  coord_fixed(ylim = c(-50,-30), xlim=c(160,180)) 

```


```{r session-info}
# Display current R session information
sessionInfo()
```
